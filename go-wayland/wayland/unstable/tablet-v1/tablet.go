// Generated by go-wayland-scanner
// https://github.com/rajveermalviya/go-wayland/cmd/go-wayland-scanner
// XML file : https://raw.githubusercontent.com/wayland-project/wayland-protocols/1.25/unstable/tablet/tablet-unstable-v1.xml
//
// tablet_unstable_v1 Protocol Copyright:
//
// Copyright 2014 © Stephen "Lyude" Chandler Paul
// Copyright 2015-2016 © Red Hat, Inc.
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice (including the
// next paragraph) shall be included in all copies or substantial
// portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package tablet

import "github.com/rajveermalviya/go-wayland/wayland/client"

// TabletManager : controller object for graphic tablet devices
//
// An object that provides access to the graphics tablets available on this
// system. All tablets are associated with a seat, to get access to the
// actual tablets, use wp_tablet_manager.get_tablet_seat.
type TabletManager struct {
	client.BaseProxy
}

// NewTabletManager : controller object for graphic tablet devices
//
// An object that provides access to the graphics tablets available on this
// system. All tablets are associated with a seat, to get access to the
// actual tablets, use wp_tablet_manager.get_tablet_seat.
func NewTabletManager(ctx *client.Context) *TabletManager {
	zwpTabletManagerV1 := &TabletManager{}
	ctx.Register(zwpTabletManagerV1)
	return zwpTabletManagerV1
}

// GetTabletSeat : get the tablet seat
//
// Get the wp_tablet_seat object for the given seat. This object
// provides access to all graphics tablets in this seat.
//
//  seat: The wl_seat object to retrieve the tablets for
func (i *TabletManager) GetTabletSeat(seat *client.Seat) (*TabletSeat, error) {
	tabletSeat := NewTabletSeat(i.Context())
	const opcode = 0
	const rLen = 8 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], tabletSeat.ID())
	l += 4
	client.PutUint32(r[l:l+4], seat.ID())
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return tabletSeat, err
}

// Destroy : release the memory for the tablet manager object
//
// Destroy the wp_tablet_manager object. Objects created from this
// object are unaffected and should be destroyed separately.
//
func (i *TabletManager) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 1
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// TabletSeat : controller object for graphic tablet devices of a seat
//
// An object that provides access to the graphics tablets available on this
// seat. After binding to this interface, the compositor sends a set of
// wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
type TabletSeat struct {
	client.BaseProxy
	tabletAddedHandlers []TabletSeatTabletAddedHandlerFunc
	toolAddedHandlers   []TabletSeatToolAddedHandlerFunc
}

// NewTabletSeat : controller object for graphic tablet devices of a seat
//
// An object that provides access to the graphics tablets available on this
// seat. After binding to this interface, the compositor sends a set of
// wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
func NewTabletSeat(ctx *client.Context) *TabletSeat {
	zwpTabletSeatV1 := &TabletSeat{}
	ctx.Register(zwpTabletSeatV1)
	return zwpTabletSeatV1
}

// Destroy : release the memory for the tablet seat object
//
// Destroy the wp_tablet_seat object. Objects created from this
// object are unaffected and should be destroyed separately.
//
func (i *TabletSeat) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// TabletSeatTabletAddedEvent : new device notification
//
// This event is sent whenever a new tablet becomes available on this
// seat. This event only provides the object id of the tablet, any
// static information about the tablet (device name, vid/pid, etc.) is
// sent through the wp_tablet interface.
type TabletSeatTabletAddedEvent struct {
	Id *Tablet
}
type TabletSeatTabletAddedHandlerFunc func(TabletSeatTabletAddedEvent)

// AddTabletAddedHandler : adds handler for TabletSeatTabletAddedEvent
func (i *TabletSeat) AddTabletAddedHandler(f TabletSeatTabletAddedHandlerFunc) {
	if f == nil {
		return
	}

	i.tabletAddedHandlers = append(i.tabletAddedHandlers, f)
}

// TabletSeatToolAddedEvent : a new tool has been used with a tablet
//
// This event is sent whenever a tool that has not previously been used
// with a tablet comes into use. This event only provides the object id
// of the tool; any static information about the tool (capabilities,
// type, etc.) is sent through the wp_tablet_tool interface.
type TabletSeatToolAddedEvent struct {
	Id *TabletTool
}
type TabletSeatToolAddedHandlerFunc func(TabletSeatToolAddedEvent)

// AddToolAddedHandler : adds handler for TabletSeatToolAddedEvent
func (i *TabletSeat) AddToolAddedHandler(f TabletSeatToolAddedHandlerFunc) {
	if f == nil {
		return
	}

	i.toolAddedHandlers = append(i.toolAddedHandlers, f)
}

func (i *TabletSeat) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.tabletAddedHandlers) == 0 {
			return
		}
		var e TabletSeatTabletAddedEvent
		l := 0
		e.Id = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*Tablet)
		l += 4
		for _, f := range i.tabletAddedHandlers {
			f(e)
		}
	case 1:
		if len(i.toolAddedHandlers) == 0 {
			return
		}
		var e TabletSeatToolAddedEvent
		l := 0
		e.Id = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*TabletTool)
		l += 4
		for _, f := range i.toolAddedHandlers {
			f(e)
		}
	}
}

// TabletTool : a physical tablet tool
//
// An object that represents a physical tool that has been, or is
// currently in use with a tablet in this seat. Each wp_tablet_tool
// object stays valid until the client destroys it; the compositor
// reuses the wp_tablet_tool object to indicate that the object's
// respective physical tool has come into proximity of a tablet again.
//
// A wp_tablet_tool object's relation to a physical tool depends on the
// tablet's ability to report serial numbers. If the tablet supports
// this capability, then the object represents a specific physical tool
// and can be identified even when used on multiple tablets.
//
// A tablet tool has a number of static characteristics, e.g. tool type,
// hardware_serial and capabilities. These capabilities are sent in an
// event sequence after the wp_tablet_seat.tool_added event before any
// actual events from this tool. This initial event sequence is
// terminated by a wp_tablet_tool.done event.
//
// Tablet tool events are grouped by wp_tablet_tool.frame events.
// Any events received before a wp_tablet_tool.frame event should be
// considered part of the same hardware state change.
type TabletTool struct {
	client.BaseProxy
	typeHandlers            []TabletToolTypeHandlerFunc
	hardwareSerialHandlers  []TabletToolHardwareSerialHandlerFunc
	hardwareIdWacomHandlers []TabletToolHardwareIdWacomHandlerFunc
	capabilityHandlers      []TabletToolCapabilityHandlerFunc
	doneHandlers            []TabletToolDoneHandlerFunc
	removedHandlers         []TabletToolRemovedHandlerFunc
	proximityInHandlers     []TabletToolProximityInHandlerFunc
	proximityOutHandlers    []TabletToolProximityOutHandlerFunc
	downHandlers            []TabletToolDownHandlerFunc
	upHandlers              []TabletToolUpHandlerFunc
	motionHandlers          []TabletToolMotionHandlerFunc
	pressureHandlers        []TabletToolPressureHandlerFunc
	distanceHandlers        []TabletToolDistanceHandlerFunc
	tiltHandlers            []TabletToolTiltHandlerFunc
	rotationHandlers        []TabletToolRotationHandlerFunc
	sliderHandlers          []TabletToolSliderHandlerFunc
	wheelHandlers           []TabletToolWheelHandlerFunc
	buttonHandlers          []TabletToolButtonHandlerFunc
	frameHandlers           []TabletToolFrameHandlerFunc
}

// NewTabletTool : a physical tablet tool
//
// An object that represents a physical tool that has been, or is
// currently in use with a tablet in this seat. Each wp_tablet_tool
// object stays valid until the client destroys it; the compositor
// reuses the wp_tablet_tool object to indicate that the object's
// respective physical tool has come into proximity of a tablet again.
//
// A wp_tablet_tool object's relation to a physical tool depends on the
// tablet's ability to report serial numbers. If the tablet supports
// this capability, then the object represents a specific physical tool
// and can be identified even when used on multiple tablets.
//
// A tablet tool has a number of static characteristics, e.g. tool type,
// hardware_serial and capabilities. These capabilities are sent in an
// event sequence after the wp_tablet_seat.tool_added event before any
// actual events from this tool. This initial event sequence is
// terminated by a wp_tablet_tool.done event.
//
// Tablet tool events are grouped by wp_tablet_tool.frame events.
// Any events received before a wp_tablet_tool.frame event should be
// considered part of the same hardware state change.
func NewTabletTool(ctx *client.Context) *TabletTool {
	zwpTabletToolV1 := &TabletTool{}
	ctx.Register(zwpTabletToolV1)
	return zwpTabletToolV1
}

// SetCursor : set the tablet tool's surface
//
// Sets the surface of the cursor used for this tool on the given
// tablet. This request only takes effect if the tool is in proximity
// of one of the requesting client's surfaces or the surface parameter
// is the current pointer surface. If there was a previous surface set
// with this request it is replaced. If surface is NULL, the cursor
// image is hidden.
//
// The parameters hotspot_x and hotspot_y define the position of the
// pointer surface relative to the pointer location. Its top-left corner
// is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
// coordinates of the pointer location, in surface-local coordinates.
//
// On surface.attach requests to the pointer surface, hotspot_x and
// hotspot_y are decremented by the x and y parameters passed to the
// request. Attach must be confirmed by wl_surface.commit as usual.
//
// The hotspot can also be updated by passing the currently set pointer
// surface to this request with new values for hotspot_x and hotspot_y.
//
// The current and pending input regions of the wl_surface are cleared,
// and wl_surface.set_input_region is ignored until the wl_surface is no
// longer used as the cursor. When the use as a cursor ends, the current
// and pending input regions become undefined, and the wl_surface is
// unmapped.
//
// This request gives the surface the role of a cursor. The role
// assigned by this request is the same as assigned by
// wl_pointer.set_cursor meaning the same surface can be
// used both as a wl_pointer cursor and a wp_tablet cursor. If the
// surface already has another role, it raises a protocol error.
// The surface may be used on multiple tablets and across multiple
// seats.
//
//  serial: serial of the enter event
//  hotspotX: surface-local x coordinate
//  hotspotY: surface-local y coordinate
func (i *TabletTool) SetCursor(serial uint32, surface *client.Surface, hotspotX, hotspotY int32) error {
	const opcode = 0
	const rLen = 8 + 4 + 4 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(serial))
	l += 4
	if surface == nil {
		client.PutUint32(r[l:l+4], 0)
		l += 4
	} else {
		client.PutUint32(r[l:l+4], surface.ID())
		l += 4
	}
	client.PutUint32(r[l:l+4], uint32(hotspotX))
	l += 4
	client.PutUint32(r[l:l+4], uint32(hotspotY))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// Destroy : destroy the tool object
//
// This destroys the client's resource for this tool object.
//
func (i *TabletTool) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 1
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

type TabletToolType uint32

// TabletToolType : a physical tool type
//
// Describes the physical type of a tool. The physical type of a tool
// generally defines its base usage.
//
// The mouse tool represents a mouse-shaped tool that is not a relative
// device but bound to the tablet's surface, providing absolute
// coordinates.
//
// The lens tool is a mouse-shaped tool with an attached lens to
// provide precision focus.
const (
	// TabletToolTypePen : Pen
	TabletToolTypePen TabletToolType = 0x140
	// TabletToolTypeEraser : Eraser
	TabletToolTypeEraser TabletToolType = 0x141
	// TabletToolTypeBrush : Brush
	TabletToolTypeBrush TabletToolType = 0x142
	// TabletToolTypePencil : Pencil
	TabletToolTypePencil TabletToolType = 0x143
	// TabletToolTypeAirbrush : Airbrush
	TabletToolTypeAirbrush TabletToolType = 0x144
	// TabletToolTypeFinger : Finger
	TabletToolTypeFinger TabletToolType = 0x145
	// TabletToolTypeMouse : Mouse
	TabletToolTypeMouse TabletToolType = 0x146
	// TabletToolTypeLens : Lens
	TabletToolTypeLens TabletToolType = 0x147
)

func (e TabletToolType) Name() string {
	switch e {
	case TabletToolTypePen:
		return "pen"
	case TabletToolTypeEraser:
		return "eraser"
	case TabletToolTypeBrush:
		return "brush"
	case TabletToolTypePencil:
		return "pencil"
	case TabletToolTypeAirbrush:
		return "airbrush"
	case TabletToolTypeFinger:
		return "finger"
	case TabletToolTypeMouse:
		return "mouse"
	case TabletToolTypeLens:
		return "lens"
	default:
		return ""
	}
}

func (e TabletToolType) Value() string {
	switch e {
	case TabletToolTypePen:
		return "0x140"
	case TabletToolTypeEraser:
		return "0x141"
	case TabletToolTypeBrush:
		return "0x142"
	case TabletToolTypePencil:
		return "0x143"
	case TabletToolTypeAirbrush:
		return "0x144"
	case TabletToolTypeFinger:
		return "0x145"
	case TabletToolTypeMouse:
		return "0x146"
	case TabletToolTypeLens:
		return "0x147"
	default:
		return ""
	}
}

func (e TabletToolType) String() string {
	return e.Name() + "=" + e.Value()
}

type TabletToolCapability uint32

// TabletToolCapability : capability flags for a tool
//
// Describes extra capabilities on a tablet.
//
// Any tool must provide x and y values, extra axes are
// device-specific.
const (
	// TabletToolCapabilityTilt : Tilt axes
	TabletToolCapabilityTilt TabletToolCapability = 1
	// TabletToolCapabilityPressure : Pressure axis
	TabletToolCapabilityPressure TabletToolCapability = 2
	// TabletToolCapabilityDistance : Distance axis
	TabletToolCapabilityDistance TabletToolCapability = 3
	// TabletToolCapabilityRotation : Z-rotation axis
	TabletToolCapabilityRotation TabletToolCapability = 4
	// TabletToolCapabilitySlider : Slider axis
	TabletToolCapabilitySlider TabletToolCapability = 5
	// TabletToolCapabilityWheel : Wheel axis
	TabletToolCapabilityWheel TabletToolCapability = 6
)

func (e TabletToolCapability) Name() string {
	switch e {
	case TabletToolCapabilityTilt:
		return "tilt"
	case TabletToolCapabilityPressure:
		return "pressure"
	case TabletToolCapabilityDistance:
		return "distance"
	case TabletToolCapabilityRotation:
		return "rotation"
	case TabletToolCapabilitySlider:
		return "slider"
	case TabletToolCapabilityWheel:
		return "wheel"
	default:
		return ""
	}
}

func (e TabletToolCapability) Value() string {
	switch e {
	case TabletToolCapabilityTilt:
		return "1"
	case TabletToolCapabilityPressure:
		return "2"
	case TabletToolCapabilityDistance:
		return "3"
	case TabletToolCapabilityRotation:
		return "4"
	case TabletToolCapabilitySlider:
		return "5"
	case TabletToolCapabilityWheel:
		return "6"
	default:
		return ""
	}
}

func (e TabletToolCapability) String() string {
	return e.Name() + "=" + e.Value()
}

type TabletToolButtonState uint32

// TabletToolButtonState : physical button state
//
// Describes the physical state of a button that produced the button event.
const (
	// TabletToolButtonStateReleased : button is not pressed
	TabletToolButtonStateReleased TabletToolButtonState = 0
	// TabletToolButtonStatePressed : button is pressed
	TabletToolButtonStatePressed TabletToolButtonState = 1
)

func (e TabletToolButtonState) Name() string {
	switch e {
	case TabletToolButtonStateReleased:
		return "released"
	case TabletToolButtonStatePressed:
		return "pressed"
	default:
		return ""
	}
}

func (e TabletToolButtonState) Value() string {
	switch e {
	case TabletToolButtonStateReleased:
		return "0"
	case TabletToolButtonStatePressed:
		return "1"
	default:
		return ""
	}
}

func (e TabletToolButtonState) String() string {
	return e.Name() + "=" + e.Value()
}

type TabletToolError uint32

// TabletToolError :
const (
	// TabletToolErrorRole : given wl_surface has another role
	TabletToolErrorRole TabletToolError = 0
)

func (e TabletToolError) Name() string {
	switch e {
	case TabletToolErrorRole:
		return "role"
	default:
		return ""
	}
}

func (e TabletToolError) Value() string {
	switch e {
	case TabletToolErrorRole:
		return "0"
	default:
		return ""
	}
}

func (e TabletToolError) String() string {
	return e.Name() + "=" + e.Value()
}

// TabletToolTypeEvent : tool type
//
// The tool type is the high-level type of the tool and usually decides
// the interaction expected from this tool.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type TabletToolTypeEvent struct {
	ToolType uint32
}
type TabletToolTypeHandlerFunc func(TabletToolTypeEvent)

// AddTypeHandler : adds handler for TabletToolTypeEvent
func (i *TabletTool) AddTypeHandler(f TabletToolTypeHandlerFunc) {
	if f == nil {
		return
	}

	i.typeHandlers = append(i.typeHandlers, f)
}

// TabletToolHardwareSerialEvent : unique hardware serial number of the tool
//
// If the physical tool can be identified by a unique 64-bit serial
// number, this event notifies the client of this serial number.
//
// If multiple tablets are available in the same seat and the tool is
// uniquely identifiable by the serial number, that tool may move
// between tablets.
//
// Otherwise, if the tool has no serial number and this event is
// missing, the tool is tied to the tablet it first comes into
// proximity with. Even if the physical tool is used on multiple
// tablets, separate wp_tablet_tool objects will be created, one per
// tablet.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type TabletToolHardwareSerialEvent struct {
	HardwareSerialHi uint32
	HardwareSerialLo uint32
}
type TabletToolHardwareSerialHandlerFunc func(TabletToolHardwareSerialEvent)

// AddHardwareSerialHandler : adds handler for TabletToolHardwareSerialEvent
func (i *TabletTool) AddHardwareSerialHandler(f TabletToolHardwareSerialHandlerFunc) {
	if f == nil {
		return
	}

	i.hardwareSerialHandlers = append(i.hardwareSerialHandlers, f)
}

// TabletToolHardwareIdWacomEvent : hardware id notification in Wacom's format
//
// This event notifies the client of a hardware id available on this tool.
//
// The hardware id is a device-specific 64-bit id that provides extra
// information about the tool in use, beyond the wl_tool.type
// enumeration. The format of the id is specific to tablets made by
// Wacom Inc. For example, the hardware id of a Wacom Grip
// Pen (a stylus) is 0x802.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type TabletToolHardwareIdWacomEvent struct {
	HardwareIdHi uint32
	HardwareIdLo uint32
}
type TabletToolHardwareIdWacomHandlerFunc func(TabletToolHardwareIdWacomEvent)

// AddHardwareIdWacomHandler : adds handler for TabletToolHardwareIdWacomEvent
func (i *TabletTool) AddHardwareIdWacomHandler(f TabletToolHardwareIdWacomHandlerFunc) {
	if f == nil {
		return
	}

	i.hardwareIdWacomHandlers = append(i.hardwareIdWacomHandlers, f)
}

// TabletToolCapabilityEvent : tool capability notification
//
// This event notifies the client of any capabilities of this tool,
// beyond the main set of x/y axes and tip up/down detection.
//
// One event is sent for each extra capability available on this tool.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type TabletToolCapabilityEvent struct {
	Capability uint32
}
type TabletToolCapabilityHandlerFunc func(TabletToolCapabilityEvent)

// AddCapabilityHandler : adds handler for TabletToolCapabilityEvent
func (i *TabletTool) AddCapabilityHandler(f TabletToolCapabilityHandlerFunc) {
	if f == nil {
		return
	}

	i.capabilityHandlers = append(i.capabilityHandlers, f)
}

// TabletToolDoneEvent : tool description events sequence complete
//
// This event signals the end of the initial burst of descriptive
// events. A client may consider the static description of the tool to
// be complete and finalize initialization of the tool.
type TabletToolDoneEvent struct{}
type TabletToolDoneHandlerFunc func(TabletToolDoneEvent)

// AddDoneHandler : adds handler for TabletToolDoneEvent
func (i *TabletTool) AddDoneHandler(f TabletToolDoneHandlerFunc) {
	if f == nil {
		return
	}

	i.doneHandlers = append(i.doneHandlers, f)
}

// TabletToolRemovedEvent : tool removed
//
// This event is sent when the tool is removed from the system and will
// send no further events. Should the physical tool come back into
// proximity later, a new wp_tablet_tool object will be created.
//
// It is compositor-dependent when a tool is removed. A compositor may
// remove a tool on proximity out, tablet removal or any other reason.
// A compositor may also keep a tool alive until shutdown.
//
// If the tool is currently in proximity, a proximity_out event will be
// sent before the removed event. See wp_tablet_tool.proximity_out for
// the handling of any buttons logically down.
//
// When this event is received, the client must wp_tablet_tool.destroy
// the object.
type TabletToolRemovedEvent struct{}
type TabletToolRemovedHandlerFunc func(TabletToolRemovedEvent)

// AddRemovedHandler : adds handler for TabletToolRemovedEvent
func (i *TabletTool) AddRemovedHandler(f TabletToolRemovedHandlerFunc) {
	if f == nil {
		return
	}

	i.removedHandlers = append(i.removedHandlers, f)
}

// TabletToolProximityInEvent : proximity in event
//
// Notification that this tool is focused on a certain surface.
//
// This event can be received when the tool has moved from one surface to
// another, or when the tool has come back into proximity above the
// surface.
//
// If any button is logically down when the tool comes into proximity,
// the respective button event is sent after the proximity_in event but
// within the same frame as the proximity_in event.
type TabletToolProximityInEvent struct {
	Serial  uint32
	Tablet  *Tablet
	Surface *client.Surface
}
type TabletToolProximityInHandlerFunc func(TabletToolProximityInEvent)

// AddProximityInHandler : adds handler for TabletToolProximityInEvent
func (i *TabletTool) AddProximityInHandler(f TabletToolProximityInHandlerFunc) {
	if f == nil {
		return
	}

	i.proximityInHandlers = append(i.proximityInHandlers, f)
}

// TabletToolProximityOutEvent : proximity out event
//
// Notification that this tool has either left proximity, or is no
// longer focused on a certain surface.
//
// When the tablet tool leaves proximity of the tablet, button release
// events are sent for each button that was held down at the time of
// leaving proximity. These events are sent before the proximity_out
// event but within the same wp_tablet.frame.
//
// If the tool stays within proximity of the tablet, but the focus
// changes from one surface to another, a button release event may not
// be sent until the button is actually released or the tool leaves the
// proximity of the tablet.
type TabletToolProximityOutEvent struct{}
type TabletToolProximityOutHandlerFunc func(TabletToolProximityOutEvent)

// AddProximityOutHandler : adds handler for TabletToolProximityOutEvent
func (i *TabletTool) AddProximityOutHandler(f TabletToolProximityOutHandlerFunc) {
	if f == nil {
		return
	}

	i.proximityOutHandlers = append(i.proximityOutHandlers, f)
}

// TabletToolDownEvent : tablet tool is making contact
//
// Sent whenever the tablet tool comes in contact with the surface of the
// tablet.
//
// If the tool is already in contact with the tablet when entering the
// input region, the client owning said region will receive a
// wp_tablet.proximity_in event, followed by a wp_tablet.down
// event and a wp_tablet.frame event.
//
// Note that this event describes logical contact, not physical
// contact. On some devices, a compositor may not consider a tool in
// logical contact until a minimum physical pressure threshold is
// exceeded.
type TabletToolDownEvent struct {
	Serial uint32
}
type TabletToolDownHandlerFunc func(TabletToolDownEvent)

// AddDownHandler : adds handler for TabletToolDownEvent
func (i *TabletTool) AddDownHandler(f TabletToolDownHandlerFunc) {
	if f == nil {
		return
	}

	i.downHandlers = append(i.downHandlers, f)
}

// TabletToolUpEvent : tablet tool is no longer making contact
//
// Sent whenever the tablet tool stops making contact with the surface of
// the tablet, or when the tablet tool moves out of the input region
// and the compositor grab (if any) is dismissed.
//
// If the tablet tool moves out of the input region while in contact
// with the surface of the tablet and the compositor does not have an
// ongoing grab on the surface, the client owning said region will
// receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
// event and a wp_tablet.frame event. If the compositor has an ongoing
// grab on this device, this event sequence is sent whenever the grab
// is dismissed in the future.
//
// Note that this event describes logical contact, not physical
// contact. On some devices, a compositor may not consider a tool out
// of logical contact until physical pressure falls below a specific
// threshold.
type TabletToolUpEvent struct{}
type TabletToolUpHandlerFunc func(TabletToolUpEvent)

// AddUpHandler : adds handler for TabletToolUpEvent
func (i *TabletTool) AddUpHandler(f TabletToolUpHandlerFunc) {
	if f == nil {
		return
	}

	i.upHandlers = append(i.upHandlers, f)
}

// TabletToolMotionEvent : motion event
//
// Sent whenever a tablet tool moves.
type TabletToolMotionEvent struct {
	X float64
	Y float64
}
type TabletToolMotionHandlerFunc func(TabletToolMotionEvent)

// AddMotionHandler : adds handler for TabletToolMotionEvent
func (i *TabletTool) AddMotionHandler(f TabletToolMotionHandlerFunc) {
	if f == nil {
		return
	}

	i.motionHandlers = append(i.motionHandlers, f)
}

// TabletToolPressureEvent : pressure change event
//
// Sent whenever the pressure axis on a tool changes. The value of this
// event is normalized to a value between 0 and 65535.
//
// Note that pressure may be nonzero even when a tool is not in logical
// contact. See the down and up events for more details.
type TabletToolPressureEvent struct {
	Pressure uint32
}
type TabletToolPressureHandlerFunc func(TabletToolPressureEvent)

// AddPressureHandler : adds handler for TabletToolPressureEvent
func (i *TabletTool) AddPressureHandler(f TabletToolPressureHandlerFunc) {
	if f == nil {
		return
	}

	i.pressureHandlers = append(i.pressureHandlers, f)
}

// TabletToolDistanceEvent : distance change event
//
// Sent whenever the distance axis on a tool changes. The value of this
// event is normalized to a value between 0 and 65535.
//
// Note that distance may be nonzero even when a tool is not in logical
// contact. See the down and up events for more details.
type TabletToolDistanceEvent struct {
	Distance uint32
}
type TabletToolDistanceHandlerFunc func(TabletToolDistanceEvent)

// AddDistanceHandler : adds handler for TabletToolDistanceEvent
func (i *TabletTool) AddDistanceHandler(f TabletToolDistanceHandlerFunc) {
	if f == nil {
		return
	}

	i.distanceHandlers = append(i.distanceHandlers, f)
}

// TabletToolTiltEvent : tilt change event
//
// Sent whenever one or both of the tilt axes on a tool change. Each tilt
// value is in 0.01 of a degree, relative to the z-axis of the tablet.
// The angle is positive when the top of a tool tilts along the
// positive x or y axis.
type TabletToolTiltEvent struct {
	TiltX int32
	TiltY int32
}
type TabletToolTiltHandlerFunc func(TabletToolTiltEvent)

// AddTiltHandler : adds handler for TabletToolTiltEvent
func (i *TabletTool) AddTiltHandler(f TabletToolTiltHandlerFunc) {
	if f == nil {
		return
	}

	i.tiltHandlers = append(i.tiltHandlers, f)
}

// TabletToolRotationEvent : z-rotation change event
//
// Sent whenever the z-rotation axis on the tool changes. The
// rotation value is in 0.01 of a degree clockwise from the tool's
// logical neutral position.
type TabletToolRotationEvent struct {
	Degrees int32
}
type TabletToolRotationHandlerFunc func(TabletToolRotationEvent)

// AddRotationHandler : adds handler for TabletToolRotationEvent
func (i *TabletTool) AddRotationHandler(f TabletToolRotationHandlerFunc) {
	if f == nil {
		return
	}

	i.rotationHandlers = append(i.rotationHandlers, f)
}

// TabletToolSliderEvent : Slider position change event
//
// Sent whenever the slider position on the tool changes. The
// value is normalized between -65535 and 65535, with 0 as the logical
// neutral position of the slider.
//
// The slider is available on e.g. the Wacom Airbrush tool.
type TabletToolSliderEvent struct {
	Position int32
}
type TabletToolSliderHandlerFunc func(TabletToolSliderEvent)

// AddSliderHandler : adds handler for TabletToolSliderEvent
func (i *TabletTool) AddSliderHandler(f TabletToolSliderHandlerFunc) {
	if f == nil {
		return
	}

	i.sliderHandlers = append(i.sliderHandlers, f)
}

// TabletToolWheelEvent : Wheel delta event
//
// Sent whenever the wheel on the tool emits an event. This event
// contains two values for the same axis change. The degrees value is
// in 0.01 of a degree in the same orientation as the
// wl_pointer.vertical_scroll axis. The clicks value is in discrete
// logical clicks of the mouse wheel. This value may be zero if the
// movement of the wheel was less than one logical click.
//
// Clients should choose either value and avoid mixing degrees and
// clicks. The compositor may accumulate values smaller than a logical
// click and emulate click events when a certain threshold is met.
// Thus, wl_tablet_tool.wheel events with non-zero clicks values may
// have different degrees values.
type TabletToolWheelEvent struct {
	Degrees int32
	Clicks  int32
}
type TabletToolWheelHandlerFunc func(TabletToolWheelEvent)

// AddWheelHandler : adds handler for TabletToolWheelEvent
func (i *TabletTool) AddWheelHandler(f TabletToolWheelHandlerFunc) {
	if f == nil {
		return
	}

	i.wheelHandlers = append(i.wheelHandlers, f)
}

// TabletToolButtonEvent : button event
//
// Sent whenever a button on the tool is pressed or released.
//
// If a button is held down when the tool moves in or out of proximity,
// button events are generated by the compositor. See
// wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
// details.
type TabletToolButtonEvent struct {
	Serial uint32
	Button uint32
	State  uint32
}
type TabletToolButtonHandlerFunc func(TabletToolButtonEvent)

// AddButtonHandler : adds handler for TabletToolButtonEvent
func (i *TabletTool) AddButtonHandler(f TabletToolButtonHandlerFunc) {
	if f == nil {
		return
	}

	i.buttonHandlers = append(i.buttonHandlers, f)
}

// TabletToolFrameEvent : frame event
//
// Marks the end of a series of axis and/or button updates from the
// tablet. The Wayland protocol requires axis updates to be sent
// sequentially, however all events within a frame should be considered
// one hardware event.
type TabletToolFrameEvent struct {
	Time uint32
}
type TabletToolFrameHandlerFunc func(TabletToolFrameEvent)

// AddFrameHandler : adds handler for TabletToolFrameEvent
func (i *TabletTool) AddFrameHandler(f TabletToolFrameHandlerFunc) {
	if f == nil {
		return
	}

	i.frameHandlers = append(i.frameHandlers, f)
}

func (i *TabletTool) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.typeHandlers) == 0 {
			return
		}
		var e TabletToolTypeEvent
		l := 0
		e.ToolType = client.Uint32(data[l : l+4])
		l += 4
		for _, f := range i.typeHandlers {
			f(e)
		}
	case 1:
		if len(i.hardwareSerialHandlers) == 0 {
			return
		}
		var e TabletToolHardwareSerialEvent
		l := 0
		e.HardwareSerialHi = client.Uint32(data[l : l+4])
		l += 4
		e.HardwareSerialLo = client.Uint32(data[l : l+4])
		l += 4
		for _, f := range i.hardwareSerialHandlers {
			f(e)
		}
	case 2:
		if len(i.hardwareIdWacomHandlers) == 0 {
			return
		}
		var e TabletToolHardwareIdWacomEvent
		l := 0
		e.HardwareIdHi = client.Uint32(data[l : l+4])
		l += 4
		e.HardwareIdLo = client.Uint32(data[l : l+4])
		l += 4
		for _, f := range i.hardwareIdWacomHandlers {
			f(e)
		}
	case 3:
		if len(i.capabilityHandlers) == 0 {
			return
		}
		var e TabletToolCapabilityEvent
		l := 0
		e.Capability = client.Uint32(data[l : l+4])
		l += 4
		for _, f := range i.capabilityHandlers {
			f(e)
		}
	case 4:
		if len(i.doneHandlers) == 0 {
			return
		}
		var e TabletToolDoneEvent
		for _, f := range i.doneHandlers {
			f(e)
		}
	case 5:
		if len(i.removedHandlers) == 0 {
			return
		}
		var e TabletToolRemovedEvent
		for _, f := range i.removedHandlers {
			f(e)
		}
	case 6:
		if len(i.proximityInHandlers) == 0 {
			return
		}
		var e TabletToolProximityInEvent
		l := 0
		e.Serial = client.Uint32(data[l : l+4])
		l += 4
		e.Tablet = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*Tablet)
		l += 4
		e.Surface = i.Context().GetProxy(client.Uint32(data[l : l+4])).(*client.Surface)
		l += 4
		for _, f := range i.proximityInHandlers {
			f(e)
		}
	case 7:
		if len(i.proximityOutHandlers) == 0 {
			return
		}
		var e TabletToolProximityOutEvent
		for _, f := range i.proximityOutHandlers {
			f(e)
		}
	case 8:
		if len(i.downHandlers) == 0 {
			return
		}
		var e TabletToolDownEvent
		l := 0
		e.Serial = client.Uint32(data[l : l+4])
		l += 4
		for _, f := range i.downHandlers {
			f(e)
		}
	case 9:
		if len(i.upHandlers) == 0 {
			return
		}
		var e TabletToolUpEvent
		for _, f := range i.upHandlers {
			f(e)
		}
	case 10:
		if len(i.motionHandlers) == 0 {
			return
		}
		var e TabletToolMotionEvent
		l := 0
		e.X = client.Fixed(data[l : l+4])
		l += 4
		e.Y = client.Fixed(data[l : l+4])
		l += 4
		for _, f := range i.motionHandlers {
			f(e)
		}
	case 11:
		if len(i.pressureHandlers) == 0 {
			return
		}
		var e TabletToolPressureEvent
		l := 0
		e.Pressure = client.Uint32(data[l : l+4])
		l += 4
		for _, f := range i.pressureHandlers {
			f(e)
		}
	case 12:
		if len(i.distanceHandlers) == 0 {
			return
		}
		var e TabletToolDistanceEvent
		l := 0
		e.Distance = client.Uint32(data[l : l+4])
		l += 4
		for _, f := range i.distanceHandlers {
			f(e)
		}
	case 13:
		if len(i.tiltHandlers) == 0 {
			return
		}
		var e TabletToolTiltEvent
		l := 0
		e.TiltX = int32(client.Uint32(data[l : l+4]))
		l += 4
		e.TiltY = int32(client.Uint32(data[l : l+4]))
		l += 4
		for _, f := range i.tiltHandlers {
			f(e)
		}
	case 14:
		if len(i.rotationHandlers) == 0 {
			return
		}
		var e TabletToolRotationEvent
		l := 0
		e.Degrees = int32(client.Uint32(data[l : l+4]))
		l += 4
		for _, f := range i.rotationHandlers {
			f(e)
		}
	case 15:
		if len(i.sliderHandlers) == 0 {
			return
		}
		var e TabletToolSliderEvent
		l := 0
		e.Position = int32(client.Uint32(data[l : l+4]))
		l += 4
		for _, f := range i.sliderHandlers {
			f(e)
		}
	case 16:
		if len(i.wheelHandlers) == 0 {
			return
		}
		var e TabletToolWheelEvent
		l := 0
		e.Degrees = int32(client.Uint32(data[l : l+4]))
		l += 4
		e.Clicks = int32(client.Uint32(data[l : l+4]))
		l += 4
		for _, f := range i.wheelHandlers {
			f(e)
		}
	case 17:
		if len(i.buttonHandlers) == 0 {
			return
		}
		var e TabletToolButtonEvent
		l := 0
		e.Serial = client.Uint32(data[l : l+4])
		l += 4
		e.Button = client.Uint32(data[l : l+4])
		l += 4
		e.State = client.Uint32(data[l : l+4])
		l += 4
		for _, f := range i.buttonHandlers {
			f(e)
		}
	case 18:
		if len(i.frameHandlers) == 0 {
			return
		}
		var e TabletToolFrameEvent
		l := 0
		e.Time = client.Uint32(data[l : l+4])
		l += 4
		for _, f := range i.frameHandlers {
			f(e)
		}
	}
}

// Tablet : graphics tablet device
//
// The wp_tablet interface represents one graphics tablet device. The
// tablet interface itself does not generate events; all events are
// generated by wp_tablet_tool objects when in proximity above a tablet.
//
// A tablet has a number of static characteristics, e.g. device name and
// pid/vid. These capabilities are sent in an event sequence after the
// wp_tablet_seat.tablet_added event. This initial event sequence is
// terminated by a wp_tablet.done event.
type Tablet struct {
	client.BaseProxy
	nameHandlers    []TabletNameHandlerFunc
	idHandlers      []TabletIdHandlerFunc
	pathHandlers    []TabletPathHandlerFunc
	doneHandlers    []TabletDoneHandlerFunc
	removedHandlers []TabletRemovedHandlerFunc
}

// NewTablet : graphics tablet device
//
// The wp_tablet interface represents one graphics tablet device. The
// tablet interface itself does not generate events; all events are
// generated by wp_tablet_tool objects when in proximity above a tablet.
//
// A tablet has a number of static characteristics, e.g. device name and
// pid/vid. These capabilities are sent in an event sequence after the
// wp_tablet_seat.tablet_added event. This initial event sequence is
// terminated by a wp_tablet.done event.
func NewTablet(ctx *client.Context) *Tablet {
	zwpTabletV1 := &Tablet{}
	ctx.Register(zwpTabletV1)
	return zwpTabletV1
}

// Destroy : destroy the tablet object
//
// This destroys the client's resource for this tablet object.
//
func (i *Tablet) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// TabletNameEvent : tablet device name
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type TabletNameEvent struct {
	Name string
}
type TabletNameHandlerFunc func(TabletNameEvent)

// AddNameHandler : adds handler for TabletNameEvent
func (i *Tablet) AddNameHandler(f TabletNameHandlerFunc) {
	if f == nil {
		return
	}

	i.nameHandlers = append(i.nameHandlers, f)
}

// TabletIdEvent : tablet device USB vendor/product id
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type TabletIdEvent struct {
	Vid uint32
	Pid uint32
}
type TabletIdHandlerFunc func(TabletIdEvent)

// AddIdHandler : adds handler for TabletIdEvent
func (i *Tablet) AddIdHandler(f TabletIdHandlerFunc) {
	if f == nil {
		return
	}

	i.idHandlers = append(i.idHandlers, f)
}

// TabletPathEvent : path to the device
//
// A system-specific device path that indicates which device is behind
// this wp_tablet. This information may be used to gather additional
// information about the device, e.g. through libwacom.
//
// A device may have more than one device path. If so, multiple
// wp_tablet.path events are sent. A device may be emulated and not
// have a device path, and in that case this event will not be sent.
//
// The format of the path is unspecified, it may be a device node, a
// sysfs path, or some other identifier. It is up to the client to
// identify the string provided.
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type TabletPathEvent struct {
	Path string
}
type TabletPathHandlerFunc func(TabletPathEvent)

// AddPathHandler : adds handler for TabletPathEvent
func (i *Tablet) AddPathHandler(f TabletPathHandlerFunc) {
	if f == nil {
		return
	}

	i.pathHandlers = append(i.pathHandlers, f)
}

// TabletDoneEvent : tablet description events sequence complete
//
// This event is sent immediately to signal the end of the initial
// burst of descriptive events. A client may consider the static
// description of the tablet to be complete and finalize initialization
// of the tablet.
type TabletDoneEvent struct{}
type TabletDoneHandlerFunc func(TabletDoneEvent)

// AddDoneHandler : adds handler for TabletDoneEvent
func (i *Tablet) AddDoneHandler(f TabletDoneHandlerFunc) {
	if f == nil {
		return
	}

	i.doneHandlers = append(i.doneHandlers, f)
}

// TabletRemovedEvent : tablet removed event
//
// Sent when the tablet has been removed from the system. When a tablet
// is removed, some tools may be removed.
//
// When this event is received, the client must wp_tablet.destroy
// the object.
type TabletRemovedEvent struct{}
type TabletRemovedHandlerFunc func(TabletRemovedEvent)

// AddRemovedHandler : adds handler for TabletRemovedEvent
func (i *Tablet) AddRemovedHandler(f TabletRemovedHandlerFunc) {
	if f == nil {
		return
	}

	i.removedHandlers = append(i.removedHandlers, f)
}

func (i *Tablet) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.nameHandlers) == 0 {
			return
		}
		var e TabletNameEvent
		l := 0
		nameLen := client.PaddedLen(int(client.Uint32(data[l : l+4])))
		l += 4
		e.Name = client.String(data[l : l+nameLen])
		l += nameLen
		for _, f := range i.nameHandlers {
			f(e)
		}
	case 1:
		if len(i.idHandlers) == 0 {
			return
		}
		var e TabletIdEvent
		l := 0
		e.Vid = client.Uint32(data[l : l+4])
		l += 4
		e.Pid = client.Uint32(data[l : l+4])
		l += 4
		for _, f := range i.idHandlers {
			f(e)
		}
	case 2:
		if len(i.pathHandlers) == 0 {
			return
		}
		var e TabletPathEvent
		l := 0
		pathLen := client.PaddedLen(int(client.Uint32(data[l : l+4])))
		l += 4
		e.Path = client.String(data[l : l+pathLen])
		l += pathLen
		for _, f := range i.pathHandlers {
			f(e)
		}
	case 3:
		if len(i.doneHandlers) == 0 {
			return
		}
		var e TabletDoneEvent
		for _, f := range i.doneHandlers {
			f(e)
		}
	case 4:
		if len(i.removedHandlers) == 0 {
			return
		}
		var e TabletRemovedEvent
		for _, f := range i.removedHandlers {
			f(e)
		}
	}
}
