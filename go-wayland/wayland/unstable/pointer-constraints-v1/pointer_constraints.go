// Generated by go-wayland-scanner
// https://github.com/rajveermalviya/go-wayland/cmd/go-wayland-scanner
// XML file : https://raw.githubusercontent.com/wayland-project/wayland-protocols/1.25/unstable/pointer-constraints/pointer-constraints-unstable-v1.xml
//
// pointer_constraints_unstable_v1 Protocol Copyright:
//
// Copyright © 2014      Jonas Ådahl
// Copyright © 2015      Red Hat Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice (including the next
// paragraph) shall be included in all copies or substantial portions of the
// Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

package pointer_constraints

import "github.com/rajveermalviya/go-wayland/wayland/client"

// PointerConstraints : constrain the movement of a pointer
//
// The global interface exposing pointer constraining functionality. It
// exposes two requests: lock_pointer for locking the pointer to its
// position, and confine_pointer for locking the pointer to a region.
//
// The lock_pointer and confine_pointer requests create the objects
// wp_locked_pointer and wp_confined_pointer respectively, and the client can
// use these objects to interact with the lock.
//
// For any surface, only one lock or confinement may be active across all
// wl_pointer objects of the same seat. If a lock or confinement is requested
// when another lock or confinement is active or requested on the same surface
// and with any of the wl_pointer objects of the same seat, an
// 'already_constrained' error will be raised.
type PointerConstraints struct {
	client.BaseProxy
}

// NewPointerConstraints : constrain the movement of a pointer
//
// The global interface exposing pointer constraining functionality. It
// exposes two requests: lock_pointer for locking the pointer to its
// position, and confine_pointer for locking the pointer to a region.
//
// The lock_pointer and confine_pointer requests create the objects
// wp_locked_pointer and wp_confined_pointer respectively, and the client can
// use these objects to interact with the lock.
//
// For any surface, only one lock or confinement may be active across all
// wl_pointer objects of the same seat. If a lock or confinement is requested
// when another lock or confinement is active or requested on the same surface
// and with any of the wl_pointer objects of the same seat, an
// 'already_constrained' error will be raised.
func NewPointerConstraints(ctx *client.Context) *PointerConstraints {
	zwpPointerConstraintsV1 := &PointerConstraints{}
	ctx.Register(zwpPointerConstraintsV1)
	return zwpPointerConstraintsV1
}

// Destroy : destroy the pointer constraints manager object
//
// Used by the client to notify the server that it will no longer use this
// pointer constraints object.
//
func (i *PointerConstraints) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// LockPointer : lock pointer to a position
//
// The lock_pointer request lets the client request to disable movements of
// the virtual pointer (i.e. the cursor), effectively locking the pointer
// to a position. This request may not take effect immediately; in the
// future, when the compositor deems implementation-specific constraints
// are satisfied, the pointer lock will be activated and the compositor
// sends a locked event.
//
// The protocol provides no guarantee that the constraints are ever
// satisfied, and does not require the compositor to send an error if the
// constraints cannot ever be satisfied. It is thus possible to request a
// lock that will never activate.
//
// There may not be another pointer constraint of any kind requested or
// active on the surface for any of the wl_pointer objects of the seat of
// the passed pointer when requesting a lock. If there is, an error will be
// raised. See general pointer lock documentation for more details.
//
// The intersection of the region passed with this request and the input
// region of the surface is used to determine where the pointer must be
// in order for the lock to activate. It is up to the compositor whether to
// warp the pointer or require some kind of user interaction for the lock
// to activate. If the region is null the surface input region is used.
//
// A surface may receive pointer focus without the lock being activated.
//
// The request creates a new object wp_locked_pointer which is used to
// interact with the lock as well as receive updates about its state. See
// the the description of wp_locked_pointer for further information.
//
// Note that while a pointer is locked, the wl_pointer objects of the
// corresponding seat will not emit any wl_pointer.motion events, but
// relative motion events will still be emitted via wp_relative_pointer
// objects of the same seat. wl_pointer.axis and wl_pointer.button events
// are unaffected.
//
//  surface: surface to lock pointer to
//  pointer: the pointer that should be locked
//  region: region of surface
//  lifetime: lock lifetime
func (i *PointerConstraints) LockPointer(surface *client.Surface, pointer *client.Pointer, region *client.Region, lifetime uint32) (*LockedPointer, error) {
	id := NewLockedPointer(i.Context())
	const opcode = 1
	const rLen = 8 + 4 + 4 + 4 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], id.ID())
	l += 4
	client.PutUint32(r[l:l+4], surface.ID())
	l += 4
	client.PutUint32(r[l:l+4], pointer.ID())
	l += 4
	if region == nil {
		client.PutUint32(r[l:l+4], 0)
		l += 4
	} else {
		client.PutUint32(r[l:l+4], region.ID())
		l += 4
	}
	client.PutUint32(r[l:l+4], uint32(lifetime))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return id, err
}

// ConfinePointer : confine pointer to a region
//
// The confine_pointer request lets the client request to confine the
// pointer cursor to a given region. This request may not take effect
// immediately; in the future, when the compositor deems implementation-
// specific constraints are satisfied, the pointer confinement will be
// activated and the compositor sends a confined event.
//
// The intersection of the region passed with this request and the input
// region of the surface is used to determine where the pointer must be
// in order for the confinement to activate. It is up to the compositor
// whether to warp the pointer or require some kind of user interaction for
// the confinement to activate. If the region is null the surface input
// region is used.
//
// The request will create a new object wp_confined_pointer which is used
// to interact with the confinement as well as receive updates about its
// state. See the the description of wp_confined_pointer for further
// information.
//
//  surface: surface to lock pointer to
//  pointer: the pointer that should be confined
//  region: region of surface
//  lifetime: confinement lifetime
func (i *PointerConstraints) ConfinePointer(surface *client.Surface, pointer *client.Pointer, region *client.Region, lifetime uint32) (*ConfinedPointer, error) {
	id := NewConfinedPointer(i.Context())
	const opcode = 2
	const rLen = 8 + 4 + 4 + 4 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], id.ID())
	l += 4
	client.PutUint32(r[l:l+4], surface.ID())
	l += 4
	client.PutUint32(r[l:l+4], pointer.ID())
	l += 4
	if region == nil {
		client.PutUint32(r[l:l+4], 0)
		l += 4
	} else {
		client.PutUint32(r[l:l+4], region.ID())
		l += 4
	}
	client.PutUint32(r[l:l+4], uint32(lifetime))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return id, err
}

type PointerConstraintsError uint32

// PointerConstraintsError : wp_pointer_constraints error values
//
// These errors can be emitted in response to wp_pointer_constraints
// requests.
const (
	// PointerConstraintsErrorAlreadyConstrained : pointer constraint already requested on that surface
	PointerConstraintsErrorAlreadyConstrained PointerConstraintsError = 1
)

func (e PointerConstraintsError) Name() string {
	switch e {
	case PointerConstraintsErrorAlreadyConstrained:
		return "already_constrained"
	default:
		return ""
	}
}

func (e PointerConstraintsError) Value() string {
	switch e {
	case PointerConstraintsErrorAlreadyConstrained:
		return "1"
	default:
		return ""
	}
}

func (e PointerConstraintsError) String() string {
	return e.Name() + "=" + e.Value()
}

type PointerConstraintsLifetime uint32

// PointerConstraintsLifetime : constraint lifetime
//
// These values represent different lifetime semantics. They are passed
// as arguments to the factory requests to specify how the constraint
// lifetimes should be managed.
const (
	PointerConstraintsLifetimeOneshot    PointerConstraintsLifetime = 1
	PointerConstraintsLifetimePersistent PointerConstraintsLifetime = 2
)

func (e PointerConstraintsLifetime) Name() string {
	switch e {
	case PointerConstraintsLifetimeOneshot:
		return "oneshot"
	case PointerConstraintsLifetimePersistent:
		return "persistent"
	default:
		return ""
	}
}

func (e PointerConstraintsLifetime) Value() string {
	switch e {
	case PointerConstraintsLifetimeOneshot:
		return "1"
	case PointerConstraintsLifetimePersistent:
		return "2"
	default:
		return ""
	}
}

func (e PointerConstraintsLifetime) String() string {
	return e.Name() + "=" + e.Value()
}

// LockedPointer : receive relative pointer motion events
//
// The wp_locked_pointer interface represents a locked pointer state.
//
// While the lock of this object is active, the wl_pointer objects of the
// associated seat will not emit any wl_pointer.motion events.
//
// This object will send the event 'locked' when the lock is activated.
// Whenever the lock is activated, it is guaranteed that the locked surface
// will already have received pointer focus and that the pointer will be
// within the region passed to the request creating this object.
//
// To unlock the pointer, send the destroy request. This will also destroy
// the wp_locked_pointer object.
//
// If the compositor decides to unlock the pointer the unlocked event is
// sent. See wp_locked_pointer.unlock for details.
//
// When unlocking, the compositor may warp the cursor position to the set
// cursor position hint. If it does, it will not result in any relative
// motion events emitted via wp_relative_pointer.
//
// If the surface the lock was requested on is destroyed and the lock is not
// yet activated, the wp_locked_pointer object is now defunct and must be
// destroyed.
type LockedPointer struct {
	client.BaseProxy
	lockedHandlers   []LockedPointerLockedHandlerFunc
	unlockedHandlers []LockedPointerUnlockedHandlerFunc
}

// NewLockedPointer : receive relative pointer motion events
//
// The wp_locked_pointer interface represents a locked pointer state.
//
// While the lock of this object is active, the wl_pointer objects of the
// associated seat will not emit any wl_pointer.motion events.
//
// This object will send the event 'locked' when the lock is activated.
// Whenever the lock is activated, it is guaranteed that the locked surface
// will already have received pointer focus and that the pointer will be
// within the region passed to the request creating this object.
//
// To unlock the pointer, send the destroy request. This will also destroy
// the wp_locked_pointer object.
//
// If the compositor decides to unlock the pointer the unlocked event is
// sent. See wp_locked_pointer.unlock for details.
//
// When unlocking, the compositor may warp the cursor position to the set
// cursor position hint. If it does, it will not result in any relative
// motion events emitted via wp_relative_pointer.
//
// If the surface the lock was requested on is destroyed and the lock is not
// yet activated, the wp_locked_pointer object is now defunct and must be
// destroyed.
func NewLockedPointer(ctx *client.Context) *LockedPointer {
	zwpLockedPointerV1 := &LockedPointer{}
	ctx.Register(zwpLockedPointerV1)
	return zwpLockedPointerV1
}

// Destroy : destroy the locked pointer object
//
// Destroy the locked pointer object. If applicable, the compositor will
// unlock the pointer.
//
func (i *LockedPointer) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetCursorPositionHint : set the pointer cursor position hint
//
// Set the cursor position hint relative to the top left corner of the
// surface.
//
// If the client is drawing its own cursor, it should update the position
// hint to the position of its own cursor. A compositor may use this
// information to warp the pointer upon unlock in order to avoid pointer
// jumps.
//
// The cursor position hint is double buffered. The new hint will only take
// effect when the associated surface gets it pending state applied. See
// wl_surface.commit for details.
//
//  surfaceX: surface-local x coordinate
//  surfaceY: surface-local y coordinate
func (i *LockedPointer) SetCursorPositionHint(surfaceX, surfaceY float64) error {
	const opcode = 1
	const rLen = 8 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutFixed(r[l:l+4], surfaceX)
	l += 4
	client.PutFixed(r[l:l+4], surfaceY)
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetRegion : set a new lock region
//
// Set a new region used to lock the pointer.
//
// The new lock region is double-buffered. The new lock region will
// only take effect when the associated surface gets its pending state
// applied. See wl_surface.commit for details.
//
// For details about the lock region, see wp_locked_pointer.
//
//  region: region of surface
func (i *LockedPointer) SetRegion(region *client.Region) error {
	const opcode = 2
	const rLen = 8 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	if region == nil {
		client.PutUint32(r[l:l+4], 0)
		l += 4
	} else {
		client.PutUint32(r[l:l+4], region.ID())
		l += 4
	}
	err := i.Context().WriteMsg(r, nil)
	return err
}

// LockedPointerLockedEvent : lock activation event
//
// Notification that the pointer lock of the seat's pointer is activated.
type LockedPointerLockedEvent struct{}
type LockedPointerLockedHandlerFunc func(LockedPointerLockedEvent)

// AddLockedHandler : adds handler for LockedPointerLockedEvent
func (i *LockedPointer) AddLockedHandler(f LockedPointerLockedHandlerFunc) {
	if f == nil {
		return
	}

	i.lockedHandlers = append(i.lockedHandlers, f)
}

// LockedPointerUnlockedEvent : lock deactivation event
//
// Notification that the pointer lock of the seat's pointer is no longer
// active. If this is a oneshot pointer lock (see
// wp_pointer_constraints.lifetime) this object is now defunct and should
// be destroyed. If this is a persistent pointer lock (see
// wp_pointer_constraints.lifetime) this pointer lock may again
// reactivate in the future.
type LockedPointerUnlockedEvent struct{}
type LockedPointerUnlockedHandlerFunc func(LockedPointerUnlockedEvent)

// AddUnlockedHandler : adds handler for LockedPointerUnlockedEvent
func (i *LockedPointer) AddUnlockedHandler(f LockedPointerUnlockedHandlerFunc) {
	if f == nil {
		return
	}

	i.unlockedHandlers = append(i.unlockedHandlers, f)
}

func (i *LockedPointer) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.lockedHandlers) == 0 {
			return
		}
		var e LockedPointerLockedEvent
		for _, f := range i.lockedHandlers {
			f(e)
		}
	case 1:
		if len(i.unlockedHandlers) == 0 {
			return
		}
		var e LockedPointerUnlockedEvent
		for _, f := range i.unlockedHandlers {
			f(e)
		}
	}
}

// ConfinedPointer : confined pointer object
//
// The wp_confined_pointer interface represents a confined pointer state.
//
// This object will send the event 'confined' when the confinement is
// activated. Whenever the confinement is activated, it is guaranteed that
// the surface the pointer is confined to will already have received pointer
// focus and that the pointer will be within the region passed to the request
// creating this object. It is up to the compositor to decide whether this
// requires some user interaction and if the pointer will warp to within the
// passed region if outside.
//
// To unconfine the pointer, send the destroy request. This will also destroy
// the wp_confined_pointer object.
//
// If the compositor decides to unconfine the pointer the unconfined event is
// sent. The wp_confined_pointer object is at this point defunct and should
// be destroyed.
type ConfinedPointer struct {
	client.BaseProxy
	confinedHandlers   []ConfinedPointerConfinedHandlerFunc
	unconfinedHandlers []ConfinedPointerUnconfinedHandlerFunc
}

// NewConfinedPointer : confined pointer object
//
// The wp_confined_pointer interface represents a confined pointer state.
//
// This object will send the event 'confined' when the confinement is
// activated. Whenever the confinement is activated, it is guaranteed that
// the surface the pointer is confined to will already have received pointer
// focus and that the pointer will be within the region passed to the request
// creating this object. It is up to the compositor to decide whether this
// requires some user interaction and if the pointer will warp to within the
// passed region if outside.
//
// To unconfine the pointer, send the destroy request. This will also destroy
// the wp_confined_pointer object.
//
// If the compositor decides to unconfine the pointer the unconfined event is
// sent. The wp_confined_pointer object is at this point defunct and should
// be destroyed.
func NewConfinedPointer(ctx *client.Context) *ConfinedPointer {
	zwpConfinedPointerV1 := &ConfinedPointer{}
	ctx.Register(zwpConfinedPointerV1)
	return zwpConfinedPointerV1
}

// Destroy : destroy the confined pointer object
//
// Destroy the confined pointer object. If applicable, the compositor will
// unconfine the pointer.
//
func (i *ConfinedPointer) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetRegion : set a new confine region
//
// Set a new region used to confine the pointer.
//
// The new confine region is double-buffered. The new confine region will
// only take effect when the associated surface gets its pending state
// applied. See wl_surface.commit for details.
//
// If the confinement is active when the new confinement region is applied
// and the pointer ends up outside of newly applied region, the pointer may
// warped to a position within the new confinement region. If warped, a
// wl_pointer.motion event will be emitted, but no
// wp_relative_pointer.relative_motion event.
//
// The compositor may also, instead of using the new region, unconfine the
// pointer.
//
// For details about the confine region, see wp_confined_pointer.
//
//  region: region of surface
func (i *ConfinedPointer) SetRegion(region *client.Region) error {
	const opcode = 1
	const rLen = 8 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	if region == nil {
		client.PutUint32(r[l:l+4], 0)
		l += 4
	} else {
		client.PutUint32(r[l:l+4], region.ID())
		l += 4
	}
	err := i.Context().WriteMsg(r, nil)
	return err
}

// ConfinedPointerConfinedEvent : pointer confined
//
// Notification that the pointer confinement of the seat's pointer is
// activated.
type ConfinedPointerConfinedEvent struct{}
type ConfinedPointerConfinedHandlerFunc func(ConfinedPointerConfinedEvent)

// AddConfinedHandler : adds handler for ConfinedPointerConfinedEvent
func (i *ConfinedPointer) AddConfinedHandler(f ConfinedPointerConfinedHandlerFunc) {
	if f == nil {
		return
	}

	i.confinedHandlers = append(i.confinedHandlers, f)
}

// ConfinedPointerUnconfinedEvent : pointer unconfined
//
// Notification that the pointer confinement of the seat's pointer is no
// longer active. If this is a oneshot pointer confinement (see
// wp_pointer_constraints.lifetime) this object is now defunct and should
// be destroyed. If this is a persistent pointer confinement (see
// wp_pointer_constraints.lifetime) this pointer confinement may again
// reactivate in the future.
type ConfinedPointerUnconfinedEvent struct{}
type ConfinedPointerUnconfinedHandlerFunc func(ConfinedPointerUnconfinedEvent)

// AddUnconfinedHandler : adds handler for ConfinedPointerUnconfinedEvent
func (i *ConfinedPointer) AddUnconfinedHandler(f ConfinedPointerUnconfinedHandlerFunc) {
	if f == nil {
		return
	}

	i.unconfinedHandlers = append(i.unconfinedHandlers, f)
}

func (i *ConfinedPointer) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.confinedHandlers) == 0 {
			return
		}
		var e ConfinedPointerConfinedEvent
		for _, f := range i.confinedHandlers {
			f(e)
		}
	case 1:
		if len(i.unconfinedHandlers) == 0 {
			return
		}
		var e ConfinedPointerUnconfinedEvent
		for _, f := range i.unconfinedHandlers {
			f(e)
		}
	}
}
