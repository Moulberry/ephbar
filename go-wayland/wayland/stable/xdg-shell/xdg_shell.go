// Generated by go-wayland-scanner
// https://github.com/rajveermalviya/go-wayland/cmd/go-wayland-scanner
// XML file : https://raw.githubusercontent.com/wayland-project/wayland-protocols/1.25/stable/xdg-shell/xdg-shell.xml
//
// xdg_shell Protocol Copyright:
//
// Copyright © 2008-2013 Kristian Høgsberg
// Copyright © 2013      Rafael Antognolli
// Copyright © 2013      Jasper St. Pierre
// Copyright © 2010-2013 Intel Corporation
// Copyright © 2015-2017 Samsung Electronics Co., Ltd
// Copyright © 2015-2017 Red Hat Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice (including the next
// paragraph) shall be included in all copies or substantial portions of the
// Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

package xdg_shell

import "github.com/rajveermalviya/go-wayland/wayland/client"

// WmBase : create desktop-style surfaces
//
// The xdg_wm_base interface is exposed as a global object enabling clients
// to turn their wl_surfaces into windows in a desktop environment. It
// defines the basic functionality needed for clients and the compositor to
// create windows that can be dragged, resized, maximized, etc, as well as
// creating transient windows such as popup menus.
type WmBase struct {
	client.BaseProxy
	pingHandlers []WmBasePingHandlerFunc
}

// NewWmBase : create desktop-style surfaces
//
// The xdg_wm_base interface is exposed as a global object enabling clients
// to turn their wl_surfaces into windows in a desktop environment. It
// defines the basic functionality needed for clients and the compositor to
// create windows that can be dragged, resized, maximized, etc, as well as
// creating transient windows such as popup menus.
func NewWmBase(ctx *client.Context) *WmBase {
	xdgWmBase := &WmBase{}
	ctx.Register(xdgWmBase)
	return xdgWmBase
}

// Destroy : destroy xdg_wm_base
//
// Destroy this xdg_wm_base object.
//
// Destroying a bound xdg_wm_base object while there are surfaces
// still alive created by this xdg_wm_base object instance is illegal
// and will result in a protocol error.
//
func (i *WmBase) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// CreatePositioner : create a positioner object
//
// Create a positioner object. A positioner object is used to position
// surfaces relative to some parent surface. See the interface description
// and xdg_surface.get_popup for details.
//
func (i *WmBase) CreatePositioner() (*Positioner, error) {
	id := NewPositioner(i.Context())
	const opcode = 1
	const rLen = 8 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], id.ID())
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return id, err
}

// GetXdgSurface : create a shell surface from a surface
//
// This creates an xdg_surface for the given surface. While xdg_surface
// itself is not a role, the corresponding surface may only be assigned
// a role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is
// illegal to create an xdg_surface for a wl_surface which already has an
// assigned role and this will result in a protocol error.
//
// This creates an xdg_surface for the given surface. An xdg_surface is
// used as basis to define a role to a given surface, such as xdg_toplevel
// or xdg_popup. It also manages functionality shared between xdg_surface
// based surface roles.
//
// See the documentation of xdg_surface for more details about what an
// xdg_surface is and how it is used.
//
func (i *WmBase) GetXdgSurface(surface *client.Surface) (*Surface, error) {
	id := NewSurface(i.Context())
	const opcode = 2
	const rLen = 8 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], id.ID())
	l += 4
	client.PutUint32(r[l:l+4], surface.ID())
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return id, err
}

// Pong : respond to a ping event
//
// A client must respond to a ping event with a pong request or
// the client may be deemed unresponsive. See xdg_wm_base.ping.
//
//  serial: serial of the ping event
func (i *WmBase) Pong(serial uint32) error {
	const opcode = 3
	const rLen = 8 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(serial))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

type WmBaseError uint32

// WmBaseError :
const (
	// WmBaseErrorRole : given wl_surface has another role
	WmBaseErrorRole WmBaseError = 0
	// WmBaseErrorDefunctSurfaces : xdg_wm_base was destroyed before children
	WmBaseErrorDefunctSurfaces WmBaseError = 1
	// WmBaseErrorNotTheTopmostPopup : the client tried to map or destroy a non-topmost popup
	WmBaseErrorNotTheTopmostPopup WmBaseError = 2
	// WmBaseErrorInvalidPopupParent : the client specified an invalid popup parent surface
	WmBaseErrorInvalidPopupParent WmBaseError = 3
	// WmBaseErrorInvalidSurfaceState : the client provided an invalid surface state
	WmBaseErrorInvalidSurfaceState WmBaseError = 4
	// WmBaseErrorInvalidPositioner : the client provided an invalid positioner
	WmBaseErrorInvalidPositioner WmBaseError = 5
)

func (e WmBaseError) Name() string {
	switch e {
	case WmBaseErrorRole:
		return "role"
	case WmBaseErrorDefunctSurfaces:
		return "defunct_surfaces"
	case WmBaseErrorNotTheTopmostPopup:
		return "not_the_topmost_popup"
	case WmBaseErrorInvalidPopupParent:
		return "invalid_popup_parent"
	case WmBaseErrorInvalidSurfaceState:
		return "invalid_surface_state"
	case WmBaseErrorInvalidPositioner:
		return "invalid_positioner"
	default:
		return ""
	}
}

func (e WmBaseError) Value() string {
	switch e {
	case WmBaseErrorRole:
		return "0"
	case WmBaseErrorDefunctSurfaces:
		return "1"
	case WmBaseErrorNotTheTopmostPopup:
		return "2"
	case WmBaseErrorInvalidPopupParent:
		return "3"
	case WmBaseErrorInvalidSurfaceState:
		return "4"
	case WmBaseErrorInvalidPositioner:
		return "5"
	default:
		return ""
	}
}

func (e WmBaseError) String() string {
	return e.Name() + "=" + e.Value()
}

// WmBasePingEvent : check if the client is alive
//
// The ping event asks the client if it's still alive. Pass the
// serial specified in the event back to the compositor by sending
// a "pong" request back with the specified serial. See xdg_wm_base.pong.
//
// Compositors can use this to determine if the client is still
// alive. It's unspecified what will happen if the client doesn't
// respond to the ping request, or in what timeframe. Clients should
// try to respond in a reasonable amount of time.
//
// A compositor is free to ping in any way it wants, but a client must
// always respond to any xdg_wm_base object it created.
type WmBasePingEvent struct {
	Serial uint32
}
type WmBasePingHandlerFunc func(WmBasePingEvent)

// AddPingHandler : adds handler for WmBasePingEvent
func (i *WmBase) AddPingHandler(f WmBasePingHandlerFunc) {
	if f == nil {
		return
	}

	i.pingHandlers = append(i.pingHandlers, f)
}

func (i *WmBase) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.pingHandlers) == 0 {
			return
		}
		var e WmBasePingEvent
		l := 0
		e.Serial = client.Uint32(data[l : l+4])
		l += 4
		for _, f := range i.pingHandlers {
			f(e)
		}
	}
}

// Positioner : child surface positioner
//
// The xdg_positioner provides a collection of rules for the placement of a
// child surface relative to a parent surface. Rules can be defined to ensure
// the child surface remains within the visible area's borders, and to
// specify how the child surface changes its position, such as sliding along
// an axis, or flipping around a rectangle. These positioner-created rules are
// constrained by the requirement that a child surface must intersect with or
// be at least partially adjacent to its parent surface.
//
// See the various requests for details about possible rules.
//
// At the time of the request, the compositor makes a copy of the rules
// specified by the xdg_positioner. Thus, after the request is complete the
// xdg_positioner object can be destroyed or reused; further changes to the
// object will have no effect on previous usages.
//
// For an xdg_positioner object to be considered complete, it must have a
// non-zero size set by set_size, and a non-zero anchor rectangle set by
// set_anchor_rect. Passing an incomplete xdg_positioner object when
// positioning a surface raises an error.
type Positioner struct {
	client.BaseProxy
}

// NewPositioner : child surface positioner
//
// The xdg_positioner provides a collection of rules for the placement of a
// child surface relative to a parent surface. Rules can be defined to ensure
// the child surface remains within the visible area's borders, and to
// specify how the child surface changes its position, such as sliding along
// an axis, or flipping around a rectangle. These positioner-created rules are
// constrained by the requirement that a child surface must intersect with or
// be at least partially adjacent to its parent surface.
//
// See the various requests for details about possible rules.
//
// At the time of the request, the compositor makes a copy of the rules
// specified by the xdg_positioner. Thus, after the request is complete the
// xdg_positioner object can be destroyed or reused; further changes to the
// object will have no effect on previous usages.
//
// For an xdg_positioner object to be considered complete, it must have a
// non-zero size set by set_size, and a non-zero anchor rectangle set by
// set_anchor_rect. Passing an incomplete xdg_positioner object when
// positioning a surface raises an error.
func NewPositioner(ctx *client.Context) *Positioner {
	xdgPositioner := &Positioner{}
	ctx.Register(xdgPositioner)
	return xdgPositioner
}

// Destroy : destroy the xdg_positioner object
//
// Notify the compositor that the xdg_positioner will no longer be used.
//
func (i *Positioner) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetSize : set the size of the to-be positioned rectangle
//
// Set the size of the surface that is to be positioned with the positioner
// object. The size is in surface-local coordinates and corresponds to the
// window geometry. See xdg_surface.set_window_geometry.
//
// If a zero or negative size is set the invalid_input error is raised.
//
//  width: width of positioned rectangle
//  height: height of positioned rectangle
func (i *Positioner) SetSize(width, height int32) error {
	const opcode = 1
	const rLen = 8 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(width))
	l += 4
	client.PutUint32(r[l:l+4], uint32(height))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetAnchorRect : set the anchor rectangle within the parent surface
//
// Specify the anchor rectangle within the parent surface that the child
// surface will be placed relative to. The rectangle is relative to the
// window geometry as defined by xdg_surface.set_window_geometry of the
// parent surface.
//
// When the xdg_positioner object is used to position a child surface, the
// anchor rectangle may not extend outside the window geometry of the
// positioned child's parent surface.
//
// If a negative size is set the invalid_input error is raised.
//
//  x: x position of anchor rectangle
//  y: y position of anchor rectangle
//  width: width of anchor rectangle
//  height: height of anchor rectangle
func (i *Positioner) SetAnchorRect(x, y, width, height int32) error {
	const opcode = 2
	const rLen = 8 + 4 + 4 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(x))
	l += 4
	client.PutUint32(r[l:l+4], uint32(y))
	l += 4
	client.PutUint32(r[l:l+4], uint32(width))
	l += 4
	client.PutUint32(r[l:l+4], uint32(height))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetAnchor : set anchor rectangle anchor
//
// Defines the anchor point for the anchor rectangle. The specified anchor
// is used derive an anchor point that the child surface will be
// positioned relative to. If a corner anchor is set (e.g. 'top_left' or
// 'bottom_right'), the anchor point will be at the specified corner;
// otherwise, the derived anchor point will be centered on the specified
// edge, or in the center of the anchor rectangle if no edge is specified.
//
//  anchor: anchor
func (i *Positioner) SetAnchor(anchor uint32) error {
	const opcode = 3
	const rLen = 8 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(anchor))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetGravity : set child surface gravity
//
// Defines in what direction a surface should be positioned, relative to
// the anchor point of the parent surface. If a corner gravity is
// specified (e.g. 'bottom_right' or 'top_left'), then the child surface
// will be placed towards the specified gravity; otherwise, the child
// surface will be centered over the anchor point on any axis that had no
// gravity specified.
//
//  gravity: gravity direction
func (i *Positioner) SetGravity(gravity uint32) error {
	const opcode = 4
	const rLen = 8 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(gravity))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetConstraintAdjustment : set the adjustment to be done when constrained
//
// Specify how the window should be positioned if the originally intended
// position caused the surface to be constrained, meaning at least
// partially outside positioning boundaries set by the compositor. The
// adjustment is set by constructing a bitmask describing the adjustment to
// be made when the surface is constrained on that axis.
//
// If no bit for one axis is set, the compositor will assume that the child
// surface should not change its position on that axis when constrained.
//
// If more than one bit for one axis is set, the order of how adjustments
// are applied is specified in the corresponding adjustment descriptions.
//
// The default adjustment is none.
//
//  constraintAdjustment: bit mask of constraint adjustments
func (i *Positioner) SetConstraintAdjustment(constraintAdjustment uint32) error {
	const opcode = 5
	const rLen = 8 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(constraintAdjustment))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetOffset : set surface position offset
//
// Specify the surface position offset relative to the position of the
// anchor on the anchor rectangle and the anchor on the surface. For
// example if the anchor of the anchor rectangle is at (x, y), the surface
// has the gravity bottom|right, and the offset is (ox, oy), the calculated
// surface position will be (x + ox, y + oy). The offset position of the
// surface is the one used for constraint testing. See
// set_constraint_adjustment.
//
// An example use case is placing a popup menu on top of a user interface
// element, while aligning the user interface element of the parent surface
// with some user interface element placed somewhere in the popup surface.
//
//  x: surface position x offset
//  y: surface position y offset
func (i *Positioner) SetOffset(x, y int32) error {
	const opcode = 6
	const rLen = 8 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(x))
	l += 4
	client.PutUint32(r[l:l+4], uint32(y))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetReactive : continuously reconstrain the surface
//
// When set reactive, the surface is reconstrained if the conditions used
// for constraining changed, e.g. the parent window moved.
//
// If the conditions changed and the popup was reconstrained, an
// xdg_popup.configure event is sent with updated geometry, followed by an
// xdg_surface.configure event.
//
func (i *Positioner) SetReactive() error {
	const opcode = 7
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetParentSize :
//
// Set the parent window geometry the compositor should use when
// positioning the popup. The compositor may use this information to
// determine the future state the popup should be constrained using. If
// this doesn't match the dimension of the parent the popup is eventually
// positioned against, the behavior is undefined.
//
// The arguments are given in the surface-local coordinate space.
//
//  parentWidth: future window geometry width of parent
//  parentHeight: future window geometry height of parent
func (i *Positioner) SetParentSize(parentWidth, parentHeight int32) error {
	const opcode = 8
	const rLen = 8 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(parentWidth))
	l += 4
	client.PutUint32(r[l:l+4], uint32(parentHeight))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetParentConfigure : set parent configure this is a response to
//
// Set the serial of an xdg_surface.configure event this positioner will be
// used in response to. The compositor may use this information together
// with set_parent_size to determine what future state the popup should be
// constrained using.
//
//  serial: serial of parent configure event
func (i *Positioner) SetParentConfigure(serial uint32) error {
	const opcode = 9
	const rLen = 8 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(serial))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

type PositionerError uint32

// PositionerError :
const (
	// PositionerErrorInvalidInput : invalid input provided
	PositionerErrorInvalidInput PositionerError = 0
)

func (e PositionerError) Name() string {
	switch e {
	case PositionerErrorInvalidInput:
		return "invalid_input"
	default:
		return ""
	}
}

func (e PositionerError) Value() string {
	switch e {
	case PositionerErrorInvalidInput:
		return "0"
	default:
		return ""
	}
}

func (e PositionerError) String() string {
	return e.Name() + "=" + e.Value()
}

type PositionerAnchor uint32

// PositionerAnchor :
const (
	PositionerAnchorNone        PositionerAnchor = 0
	PositionerAnchorTop         PositionerAnchor = 1
	PositionerAnchorBottom      PositionerAnchor = 2
	PositionerAnchorLeft        PositionerAnchor = 3
	PositionerAnchorRight       PositionerAnchor = 4
	PositionerAnchorTopLeft     PositionerAnchor = 5
	PositionerAnchorBottomLeft  PositionerAnchor = 6
	PositionerAnchorTopRight    PositionerAnchor = 7
	PositionerAnchorBottomRight PositionerAnchor = 8
)

func (e PositionerAnchor) Name() string {
	switch e {
	case PositionerAnchorNone:
		return "none"
	case PositionerAnchorTop:
		return "top"
	case PositionerAnchorBottom:
		return "bottom"
	case PositionerAnchorLeft:
		return "left"
	case PositionerAnchorRight:
		return "right"
	case PositionerAnchorTopLeft:
		return "top_left"
	case PositionerAnchorBottomLeft:
		return "bottom_left"
	case PositionerAnchorTopRight:
		return "top_right"
	case PositionerAnchorBottomRight:
		return "bottom_right"
	default:
		return ""
	}
}

func (e PositionerAnchor) Value() string {
	switch e {
	case PositionerAnchorNone:
		return "0"
	case PositionerAnchorTop:
		return "1"
	case PositionerAnchorBottom:
		return "2"
	case PositionerAnchorLeft:
		return "3"
	case PositionerAnchorRight:
		return "4"
	case PositionerAnchorTopLeft:
		return "5"
	case PositionerAnchorBottomLeft:
		return "6"
	case PositionerAnchorTopRight:
		return "7"
	case PositionerAnchorBottomRight:
		return "8"
	default:
		return ""
	}
}

func (e PositionerAnchor) String() string {
	return e.Name() + "=" + e.Value()
}

type PositionerGravity uint32

// PositionerGravity :
const (
	PositionerGravityNone        PositionerGravity = 0
	PositionerGravityTop         PositionerGravity = 1
	PositionerGravityBottom      PositionerGravity = 2
	PositionerGravityLeft        PositionerGravity = 3
	PositionerGravityRight       PositionerGravity = 4
	PositionerGravityTopLeft     PositionerGravity = 5
	PositionerGravityBottomLeft  PositionerGravity = 6
	PositionerGravityTopRight    PositionerGravity = 7
	PositionerGravityBottomRight PositionerGravity = 8
)

func (e PositionerGravity) Name() string {
	switch e {
	case PositionerGravityNone:
		return "none"
	case PositionerGravityTop:
		return "top"
	case PositionerGravityBottom:
		return "bottom"
	case PositionerGravityLeft:
		return "left"
	case PositionerGravityRight:
		return "right"
	case PositionerGravityTopLeft:
		return "top_left"
	case PositionerGravityBottomLeft:
		return "bottom_left"
	case PositionerGravityTopRight:
		return "top_right"
	case PositionerGravityBottomRight:
		return "bottom_right"
	default:
		return ""
	}
}

func (e PositionerGravity) Value() string {
	switch e {
	case PositionerGravityNone:
		return "0"
	case PositionerGravityTop:
		return "1"
	case PositionerGravityBottom:
		return "2"
	case PositionerGravityLeft:
		return "3"
	case PositionerGravityRight:
		return "4"
	case PositionerGravityTopLeft:
		return "5"
	case PositionerGravityBottomLeft:
		return "6"
	case PositionerGravityTopRight:
		return "7"
	case PositionerGravityBottomRight:
		return "8"
	default:
		return ""
	}
}

func (e PositionerGravity) String() string {
	return e.Name() + "=" + e.Value()
}

type PositionerConstraintAdjustment uint32

// PositionerConstraintAdjustment : constraint adjustments
//
// The constraint adjustment value define ways the compositor will adjust
// the position of the surface, if the unadjusted position would result
// in the surface being partly constrained.
//
// Whether a surface is considered 'constrained' is left to the compositor
// to determine. For example, the surface may be partly outside the
// compositor's defined 'work area', thus necessitating the child surface's
// position be adjusted until it is entirely inside the work area.
//
// The adjustments can be combined, according to a defined precedence: 1)
// Flip, 2) Slide, 3) Resize.
const (
	PositionerConstraintAdjustmentNone    PositionerConstraintAdjustment = 0
	PositionerConstraintAdjustmentSlideX  PositionerConstraintAdjustment = 1
	PositionerConstraintAdjustmentSlideY  PositionerConstraintAdjustment = 2
	PositionerConstraintAdjustmentFlipX   PositionerConstraintAdjustment = 4
	PositionerConstraintAdjustmentFlipY   PositionerConstraintAdjustment = 8
	PositionerConstraintAdjustmentResizeX PositionerConstraintAdjustment = 16
	PositionerConstraintAdjustmentResizeY PositionerConstraintAdjustment = 32
)

func (e PositionerConstraintAdjustment) Name() string {
	switch e {
	case PositionerConstraintAdjustmentNone:
		return "none"
	case PositionerConstraintAdjustmentSlideX:
		return "slide_x"
	case PositionerConstraintAdjustmentSlideY:
		return "slide_y"
	case PositionerConstraintAdjustmentFlipX:
		return "flip_x"
	case PositionerConstraintAdjustmentFlipY:
		return "flip_y"
	case PositionerConstraintAdjustmentResizeX:
		return "resize_x"
	case PositionerConstraintAdjustmentResizeY:
		return "resize_y"
	default:
		return ""
	}
}

func (e PositionerConstraintAdjustment) Value() string {
	switch e {
	case PositionerConstraintAdjustmentNone:
		return "0"
	case PositionerConstraintAdjustmentSlideX:
		return "1"
	case PositionerConstraintAdjustmentSlideY:
		return "2"
	case PositionerConstraintAdjustmentFlipX:
		return "4"
	case PositionerConstraintAdjustmentFlipY:
		return "8"
	case PositionerConstraintAdjustmentResizeX:
		return "16"
	case PositionerConstraintAdjustmentResizeY:
		return "32"
	default:
		return ""
	}
}

func (e PositionerConstraintAdjustment) String() string {
	return e.Name() + "=" + e.Value()
}

// Surface : desktop user interface surface base interface
//
// An interface that may be implemented by a wl_surface, for
// implementations that provide a desktop-style user interface.
//
// It provides a base set of functionality required to construct user
// interface elements requiring management by the compositor, such as
// toplevel windows, menus, etc. The types of functionality are split into
// xdg_surface roles.
//
// Creating an xdg_surface does not set the role for a wl_surface. In order
// to map an xdg_surface, the client must create a role-specific object
// using, e.g., get_toplevel, get_popup. The wl_surface for any given
// xdg_surface can have at most one role, and may not be assigned any role
// not based on xdg_surface.
//
// A role must be assigned before any other requests are made to the
// xdg_surface object.
//
// The client must call wl_surface.commit on the corresponding wl_surface
// for the xdg_surface state to take effect.
//
// Creating an xdg_surface from a wl_surface which has a buffer attached or
// committed is a client error, and any attempts by a client to attach or
// manipulate a buffer prior to the first xdg_surface.configure call must
// also be treated as errors.
//
// After creating a role-specific object and setting it up, the client must
// perform an initial commit without any buffer attached. The compositor
// will reply with an xdg_surface.configure event. The client must
// acknowledge it and is then allowed to attach a buffer to map the surface.
//
// Mapping an xdg_surface-based role surface is defined as making it
// possible for the surface to be shown by the compositor. Note that
// a mapped surface is not guaranteed to be visible once it is mapped.
//
// For an xdg_surface to be mapped by the compositor, the following
// conditions must be met:
// (1) the client has assigned an xdg_surface-based role to the surface
// (2) the client has set and committed the xdg_surface state and the
// role-dependent state to the surface
// (3) the client has committed a buffer to the surface
//
// A newly-unmapped surface is considered to have met condition (1) out
// of the 3 required conditions for mapping a surface if its role surface
// has not been destroyed, i.e. the client must perform the initial commit
// again before attaching a buffer.
type Surface struct {
	client.BaseProxy
	configureHandlers []SurfaceConfigureHandlerFunc
}

// NewSurface : desktop user interface surface base interface
//
// An interface that may be implemented by a wl_surface, for
// implementations that provide a desktop-style user interface.
//
// It provides a base set of functionality required to construct user
// interface elements requiring management by the compositor, such as
// toplevel windows, menus, etc. The types of functionality are split into
// xdg_surface roles.
//
// Creating an xdg_surface does not set the role for a wl_surface. In order
// to map an xdg_surface, the client must create a role-specific object
// using, e.g., get_toplevel, get_popup. The wl_surface for any given
// xdg_surface can have at most one role, and may not be assigned any role
// not based on xdg_surface.
//
// A role must be assigned before any other requests are made to the
// xdg_surface object.
//
// The client must call wl_surface.commit on the corresponding wl_surface
// for the xdg_surface state to take effect.
//
// Creating an xdg_surface from a wl_surface which has a buffer attached or
// committed is a client error, and any attempts by a client to attach or
// manipulate a buffer prior to the first xdg_surface.configure call must
// also be treated as errors.
//
// After creating a role-specific object and setting it up, the client must
// perform an initial commit without any buffer attached. The compositor
// will reply with an xdg_surface.configure event. The client must
// acknowledge it and is then allowed to attach a buffer to map the surface.
//
// Mapping an xdg_surface-based role surface is defined as making it
// possible for the surface to be shown by the compositor. Note that
// a mapped surface is not guaranteed to be visible once it is mapped.
//
// For an xdg_surface to be mapped by the compositor, the following
// conditions must be met:
// (1) the client has assigned an xdg_surface-based role to the surface
// (2) the client has set and committed the xdg_surface state and the
// role-dependent state to the surface
// (3) the client has committed a buffer to the surface
//
// A newly-unmapped surface is considered to have met condition (1) out
// of the 3 required conditions for mapping a surface if its role surface
// has not been destroyed, i.e. the client must perform the initial commit
// again before attaching a buffer.
func NewSurface(ctx *client.Context) *Surface {
	xdgSurface := &Surface{}
	ctx.Register(xdgSurface)
	return xdgSurface
}

// Destroy : destroy the xdg_surface
//
// Destroy the xdg_surface object. An xdg_surface must only be destroyed
// after its role object has been destroyed.
//
func (i *Surface) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// GetToplevel : assign the xdg_toplevel surface role
//
// This creates an xdg_toplevel object for the given xdg_surface and gives
// the associated wl_surface the xdg_toplevel role.
//
// See the documentation of xdg_toplevel for more details about what an
// xdg_toplevel is and how it is used.
//
func (i *Surface) GetToplevel() (*Toplevel, error) {
	id := NewToplevel(i.Context())
	const opcode = 1
	const rLen = 8 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], id.ID())
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return id, err
}

// GetPopup : assign the xdg_popup surface role
//
// This creates an xdg_popup object for the given xdg_surface and gives
// the associated wl_surface the xdg_popup role.
//
// If null is passed as a parent, a parent surface must be specified using
// some other protocol, before committing the initial state.
//
// See the documentation of xdg_popup for more details about what an
// xdg_popup is and how it is used.
//
func (i *Surface) GetPopup(parent *Surface, positioner *Positioner) (*Popup, error) {
	id := NewPopup(i.Context())
	const opcode = 2
	const rLen = 8 + 4 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], id.ID())
	l += 4
	if parent == nil {
		client.PutUint32(r[l:l+4], 0)
		l += 4
	} else {
		client.PutUint32(r[l:l+4], parent.ID())
		l += 4
	}
	client.PutUint32(r[l:l+4], positioner.ID())
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return id, err
}

// SetWindowGeometry : set the new window geometry
//
// The window geometry of a surface is its "visible bounds" from the
// user's perspective. Client-side decorations often have invisible
// portions like drop-shadows which should be ignored for the
// purposes of aligning, placing and constraining windows.
//
// The window geometry is double buffered, and will be applied at the
// time wl_surface.commit of the corresponding wl_surface is called.
//
// When maintaining a position, the compositor should treat the (x, y)
// coordinate of the window geometry as the top left corner of the window.
// A client changing the (x, y) window geometry coordinate should in
// general not alter the position of the window.
//
// Once the window geometry of the surface is set, it is not possible to
// unset it, and it will remain the same until set_window_geometry is
// called again, even if a new subsurface or buffer is attached.
//
// If never set, the value is the full bounds of the surface,
// including any subsurfaces. This updates dynamically on every
// commit. This unset is meant for extremely simple clients.
//
// The arguments are given in the surface-local coordinate space of
// the wl_surface associated with this xdg_surface.
//
// The width and height must be greater than zero. Setting an invalid size
// will raise an error. When applied, the effective window geometry will be
// the set window geometry clamped to the bounding rectangle of the
// combined geometry of the surface of the xdg_surface and the associated
// subsurfaces.
//
func (i *Surface) SetWindowGeometry(x, y, width, height int32) error {
	const opcode = 3
	const rLen = 8 + 4 + 4 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(x))
	l += 4
	client.PutUint32(r[l:l+4], uint32(y))
	l += 4
	client.PutUint32(r[l:l+4], uint32(width))
	l += 4
	client.PutUint32(r[l:l+4], uint32(height))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// AckConfigure : ack a configure event
//
// When a configure event is received, if a client commits the
// surface in response to the configure event, then the client
// must make an ack_configure request sometime before the commit
// request, passing along the serial of the configure event.
//
// For instance, for toplevel surfaces the compositor might use this
// information to move a surface to the top left only when the client has
// drawn itself for the maximized or fullscreen state.
//
// If the client receives multiple configure events before it
// can respond to one, it only has to ack the last configure event.
//
// A client is not required to commit immediately after sending
// an ack_configure request - it may even ack_configure several times
// before its next surface commit.
//
// A client may send multiple ack_configure requests before committing, but
// only the last request sent before a commit indicates which configure
// event the client really is responding to.
//
//  serial: the serial from the configure event
func (i *Surface) AckConfigure(serial uint32) error {
	const opcode = 4
	const rLen = 8 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(serial))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

type SurfaceError uint32

// SurfaceError :
const (
	SurfaceErrorNotConstructed     SurfaceError = 1
	SurfaceErrorAlreadyConstructed SurfaceError = 2
	SurfaceErrorUnconfiguredBuffer SurfaceError = 3
)

func (e SurfaceError) Name() string {
	switch e {
	case SurfaceErrorNotConstructed:
		return "not_constructed"
	case SurfaceErrorAlreadyConstructed:
		return "already_constructed"
	case SurfaceErrorUnconfiguredBuffer:
		return "unconfigured_buffer"
	default:
		return ""
	}
}

func (e SurfaceError) Value() string {
	switch e {
	case SurfaceErrorNotConstructed:
		return "1"
	case SurfaceErrorAlreadyConstructed:
		return "2"
	case SurfaceErrorUnconfiguredBuffer:
		return "3"
	default:
		return ""
	}
}

func (e SurfaceError) String() string {
	return e.Name() + "=" + e.Value()
}

// SurfaceConfigureEvent : suggest a surface change
//
// The configure event marks the end of a configure sequence. A configure
// sequence is a set of one or more events configuring the state of the
// xdg_surface, including the final xdg_surface.configure event.
//
// Where applicable, xdg_surface surface roles will during a configure
// sequence extend this event as a latched state sent as events before the
// xdg_surface.configure event. Such events should be considered to make up
// a set of atomically applied configuration states, where the
// xdg_surface.configure commits the accumulated state.
//
// Clients should arrange their surface for the new states, and then send
// an ack_configure request with the serial sent in this configure event at
// some point before committing the new surface.
//
// If the client receives multiple configure events before it can respond
// to one, it is free to discard all but the last event it received.
type SurfaceConfigureEvent struct {
	Serial uint32
}
type SurfaceConfigureHandlerFunc func(SurfaceConfigureEvent)

// AddConfigureHandler : adds handler for SurfaceConfigureEvent
func (i *Surface) AddConfigureHandler(f SurfaceConfigureHandlerFunc) {
	if f == nil {
		return
	}

	i.configureHandlers = append(i.configureHandlers, f)
}

func (i *Surface) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.configureHandlers) == 0 {
			return
		}
		var e SurfaceConfigureEvent
		l := 0
		e.Serial = client.Uint32(data[l : l+4])
		l += 4
		for _, f := range i.configureHandlers {
			f(e)
		}
	}
}

// Toplevel : toplevel surface
//
// This interface defines an xdg_surface role which allows a surface to,
// among other things, set window-like properties such as maximize,
// fullscreen, and minimize, set application-specific metadata like title and
// id, and well as trigger user interactive operations such as interactive
// resize and move.
//
// Unmapping an xdg_toplevel means that the surface cannot be shown
// by the compositor until it is explicitly mapped again.
// All active operations (e.g., move, resize) are canceled and all
// attributes (e.g. title, state, stacking, ...) are discarded for
// an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to
// the state it had right after xdg_surface.get_toplevel. The client
// can re-map the toplevel by perfoming a commit without any buffer
// attached, waiting for a configure event and handling it as usual (see
// xdg_surface description).
//
// Attaching a null buffer to a toplevel unmaps the surface.
type Toplevel struct {
	client.BaseProxy
	configureHandlers       []ToplevelConfigureHandlerFunc
	closeHandlers           []ToplevelCloseHandlerFunc
	configureBoundsHandlers []ToplevelConfigureBoundsHandlerFunc
}

// NewToplevel : toplevel surface
//
// This interface defines an xdg_surface role which allows a surface to,
// among other things, set window-like properties such as maximize,
// fullscreen, and minimize, set application-specific metadata like title and
// id, and well as trigger user interactive operations such as interactive
// resize and move.
//
// Unmapping an xdg_toplevel means that the surface cannot be shown
// by the compositor until it is explicitly mapped again.
// All active operations (e.g., move, resize) are canceled and all
// attributes (e.g. title, state, stacking, ...) are discarded for
// an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to
// the state it had right after xdg_surface.get_toplevel. The client
// can re-map the toplevel by perfoming a commit without any buffer
// attached, waiting for a configure event and handling it as usual (see
// xdg_surface description).
//
// Attaching a null buffer to a toplevel unmaps the surface.
func NewToplevel(ctx *client.Context) *Toplevel {
	xdgToplevel := &Toplevel{}
	ctx.Register(xdgToplevel)
	return xdgToplevel
}

// Destroy : destroy the xdg_toplevel
//
// This request destroys the role surface and unmaps the surface;
// see "Unmapping" behavior in interface section for details.
//
func (i *Toplevel) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetParent : set the parent of this surface
//
// Set the "parent" of this surface. This surface should be stacked
// above the parent surface and all other ancestor surfaces.
//
// Parent windows should be set on dialogs, toolboxes, or other
// "auxiliary" surfaces, so that the parent is raised when the dialog
// is raised.
//
// Setting a null parent for a child window removes any parent-child
// relationship for the child. Setting a null parent for a window which
// currently has no parent is a no-op.
//
// If the parent is unmapped then its children are managed as
// though the parent of the now-unmapped parent has become the
// parent of this surface. If no parent exists for the now-unmapped
// parent then the children are managed as though they have no
// parent surface.
//
func (i *Toplevel) SetParent(parent *Toplevel) error {
	const opcode = 1
	const rLen = 8 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	if parent == nil {
		client.PutUint32(r[l:l+4], 0)
		l += 4
	} else {
		client.PutUint32(r[l:l+4], parent.ID())
		l += 4
	}
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetTitle : set surface title
//
// Set a short title for the surface.
//
// This string may be used to identify the surface in a task bar,
// window list, or other user interface elements provided by the
// compositor.
//
// The string must be encoded in UTF-8.
//
func (i *Toplevel) SetTitle(title string) error {
	const opcode = 2
	titleLen := client.PaddedLen(len(title) + 1)
	rLen := 8 + (4 + titleLen)
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutString(r[l:l+(4+titleLen)], title, titleLen)
	l += (4 + titleLen)
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetAppId : set application ID
//
// Set an application identifier for the surface.
//
// The app ID identifies the general class of applications to which
// the surface belongs. The compositor can use this to group multiple
// surfaces together, or to determine how to launch a new application.
//
// For D-Bus activatable applications, the app ID is used as the D-Bus
// service name.
//
// The compositor shell will try to group application surfaces together
// by their app ID. As a best practice, it is suggested to select app
// ID's that match the basename of the application's .desktop file.
// For example, "org.freedesktop.FooViewer" where the .desktop file is
// "org.freedesktop.FooViewer.desktop".
//
// Like other properties, a set_app_id request can be sent after the
// xdg_toplevel has been mapped to update the property.
//
// See the desktop-entry specification [0] for more details on
// application identifiers and how they relate to well-known D-Bus
// names and .desktop files.
//
// [0] http://standards.freedesktop.org/desktop-entry-spec/
//
func (i *Toplevel) SetAppId(appId string) error {
	const opcode = 3
	appIdLen := client.PaddedLen(len(appId) + 1)
	rLen := 8 + (4 + appIdLen)
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutString(r[l:l+(4+appIdLen)], appId, appIdLen)
	l += (4 + appIdLen)
	err := i.Context().WriteMsg(r, nil)
	return err
}

// ShowWindowMenu : show the window menu
//
// Clients implementing client-side decorations might want to show
// a context menu when right-clicking on the decorations, giving the
// user a menu that they can use to maximize or minimize the window.
//
// This request asks the compositor to pop up such a window menu at
// the given position, relative to the local surface coordinates of
// the parent surface. There are no guarantees as to what menu items
// the window menu contains.
//
// This request must be used in response to some sort of user action
// like a button press, key press, or touch down event.
//
//  seat: the wl_seat of the user event
//  serial: the serial of the user event
//  x: the x position to pop up the window menu at
//  y: the y position to pop up the window menu at
func (i *Toplevel) ShowWindowMenu(seat *client.Seat, serial uint32, x, y int32) error {
	const opcode = 4
	const rLen = 8 + 4 + 4 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], seat.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(serial))
	l += 4
	client.PutUint32(r[l:l+4], uint32(x))
	l += 4
	client.PutUint32(r[l:l+4], uint32(y))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// Move : start an interactive move
//
// Start an interactive, user-driven move of the surface.
//
// This request must be used in response to some sort of user action
// like a button press, key press, or touch down event. The passed
// serial is used to determine the type of interactive move (touch,
// pointer, etc).
//
// The server may ignore move requests depending on the state of
// the surface (e.g. fullscreen or maximized), or if the passed serial
// is no longer valid.
//
// If triggered, the surface will lose the focus of the device
// (wl_pointer, wl_touch, etc) used for the move. It is up to the
// compositor to visually indicate that the move is taking place, such as
// updating a pointer cursor, during the move. There is no guarantee
// that the device focus will return when the move is completed.
//
//  seat: the wl_seat of the user event
//  serial: the serial of the user event
func (i *Toplevel) Move(seat *client.Seat, serial uint32) error {
	const opcode = 5
	const rLen = 8 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], seat.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(serial))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// Resize : start an interactive resize
//
// Start a user-driven, interactive resize of the surface.
//
// This request must be used in response to some sort of user action
// like a button press, key press, or touch down event. The passed
// serial is used to determine the type of interactive resize (touch,
// pointer, etc).
//
// The server may ignore resize requests depending on the state of
// the surface (e.g. fullscreen or maximized).
//
// If triggered, the client will receive configure events with the
// "resize" state enum value and the expected sizes. See the "resize"
// enum value for more details about what is required. The client
// must also acknowledge configure events using "ack_configure". After
// the resize is completed, the client will receive another "configure"
// event without the resize state.
//
// If triggered, the surface also will lose the focus of the device
// (wl_pointer, wl_touch, etc) used for the resize. It is up to the
// compositor to visually indicate that the resize is taking place,
// such as updating a pointer cursor, during the resize. There is no
// guarantee that the device focus will return when the resize is
// completed.
//
// The edges parameter specifies how the surface should be resized, and
// is one of the values of the resize_edge enum. Values not matching
// a variant of the enum will cause a protocol error. The compositor
// may use this information to update the surface position for example
// when dragging the top left corner. The compositor may also use
// this information to adapt its behavior, e.g. choose an appropriate
// cursor image.
//
//  seat: the wl_seat of the user event
//  serial: the serial of the user event
//  edges: which edge or corner is being dragged
func (i *Toplevel) Resize(seat *client.Seat, serial, edges uint32) error {
	const opcode = 6
	const rLen = 8 + 4 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], seat.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(serial))
	l += 4
	client.PutUint32(r[l:l+4], uint32(edges))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetMaxSize : set the maximum size
//
// Set a maximum size for the window.
//
// The client can specify a maximum size so that the compositor does
// not try to configure the window beyond this size.
//
// The width and height arguments are in window geometry coordinates.
// See xdg_surface.set_window_geometry.
//
// Values set in this way are double-buffered. They will get applied
// on the next commit.
//
// The compositor can use this information to allow or disallow
// different states like maximize or fullscreen and draw accurate
// animations.
//
// Similarly, a tiling window manager may use this information to
// place and resize client windows in a more effective way.
//
// The client should not rely on the compositor to obey the maximum
// size. The compositor may decide to ignore the values set by the
// client and request a larger size.
//
// If never set, or a value of zero in the request, means that the
// client has no expected maximum size in the given dimension.
// As a result, a client wishing to reset the maximum size
// to an unspecified state can use zero for width and height in the
// request.
//
// Requesting a maximum size to be smaller than the minimum size of
// a surface is illegal and will result in a protocol error.
//
// The width and height must be greater than or equal to zero. Using
// strictly negative values for width and height will result in a
// protocol error.
//
func (i *Toplevel) SetMaxSize(width, height int32) error {
	const opcode = 7
	const rLen = 8 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(width))
	l += 4
	client.PutUint32(r[l:l+4], uint32(height))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetMinSize : set the minimum size
//
// Set a minimum size for the window.
//
// The client can specify a minimum size so that the compositor does
// not try to configure the window below this size.
//
// The width and height arguments are in window geometry coordinates.
// See xdg_surface.set_window_geometry.
//
// Values set in this way are double-buffered. They will get applied
// on the next commit.
//
// The compositor can use this information to allow or disallow
// different states like maximize or fullscreen and draw accurate
// animations.
//
// Similarly, a tiling window manager may use this information to
// place and resize client windows in a more effective way.
//
// The client should not rely on the compositor to obey the minimum
// size. The compositor may decide to ignore the values set by the
// client and request a smaller size.
//
// If never set, or a value of zero in the request, means that the
// client has no expected minimum size in the given dimension.
// As a result, a client wishing to reset the minimum size
// to an unspecified state can use zero for width and height in the
// request.
//
// Requesting a minimum size to be larger than the maximum size of
// a surface is illegal and will result in a protocol error.
//
// The width and height must be greater than or equal to zero. Using
// strictly negative values for width and height will result in a
// protocol error.
//
func (i *Toplevel) SetMinSize(width, height int32) error {
	const opcode = 8
	const rLen = 8 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], uint32(width))
	l += 4
	client.PutUint32(r[l:l+4], uint32(height))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetMaximized : maximize the window
//
// Maximize the surface.
//
// After requesting that the surface should be maximized, the compositor
// will respond by emitting a configure event. Whether this configure
// actually sets the window maximized is subject to compositor policies.
// The client must then update its content, drawing in the configured
// state. The client must also acknowledge the configure when committing
// the new content (see ack_configure).
//
// It is up to the compositor to decide how and where to maximize the
// surface, for example which output and what region of the screen should
// be used.
//
// If the surface was already maximized, the compositor will still emit
// a configure event with the "maximized" state.
//
// If the surface is in a fullscreen state, this request has no direct
// effect. It may alter the state the surface is returned to when
// unmaximized unless overridden by the compositor.
//
func (i *Toplevel) SetMaximized() error {
	const opcode = 9
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// UnsetMaximized : unmaximize the window
//
// Unmaximize the surface.
//
// After requesting that the surface should be unmaximized, the compositor
// will respond by emitting a configure event. Whether this actually
// un-maximizes the window is subject to compositor policies.
// If available and applicable, the compositor will include the window
// geometry dimensions the window had prior to being maximized in the
// configure event. The client must then update its content, drawing it in
// the configured state. The client must also acknowledge the configure
// when committing the new content (see ack_configure).
//
// It is up to the compositor to position the surface after it was
// unmaximized; usually the position the surface had before maximizing, if
// applicable.
//
// If the surface was already not maximized, the compositor will still
// emit a configure event without the "maximized" state.
//
// If the surface is in a fullscreen state, this request has no direct
// effect. It may alter the state the surface is returned to when
// unmaximized unless overridden by the compositor.
//
func (i *Toplevel) UnsetMaximized() error {
	const opcode = 10
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetFullscreen : set the window as fullscreen on an output
//
// Make the surface fullscreen.
//
// After requesting that the surface should be fullscreened, the
// compositor will respond by emitting a configure event. Whether the
// client is actually put into a fullscreen state is subject to compositor
// policies. The client must also acknowledge the configure when
// committing the new content (see ack_configure).
//
// The output passed by the request indicates the client's preference as
// to which display it should be set fullscreen on. If this value is NULL,
// it's up to the compositor to choose which display will be used to map
// this surface.
//
// If the surface doesn't cover the whole output, the compositor will
// position the surface in the center of the output and compensate with
// with border fill covering the rest of the output. The content of the
// border fill is undefined, but should be assumed to be in some way that
// attempts to blend into the surrounding area (e.g. solid black).
//
// If the fullscreened surface is not opaque, the compositor must make
// sure that other screen content not part of the same surface tree (made
// up of subsurfaces, popups or similarly coupled surfaces) are not
// visible below the fullscreened surface.
//
func (i *Toplevel) SetFullscreen(output *client.Output) error {
	const opcode = 11
	const rLen = 8 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	if output == nil {
		client.PutUint32(r[l:l+4], 0)
		l += 4
	} else {
		client.PutUint32(r[l:l+4], output.ID())
		l += 4
	}
	err := i.Context().WriteMsg(r, nil)
	return err
}

// UnsetFullscreen : unset the window as fullscreen
//
// Make the surface no longer fullscreen.
//
// After requesting that the surface should be unfullscreened, the
// compositor will respond by emitting a configure event.
// Whether this actually removes the fullscreen state of the client is
// subject to compositor policies.
//
// Making a surface unfullscreen sets states for the surface based on the following:
// * the state(s) it may have had before becoming fullscreen
// * any state(s) decided by the compositor
// * any state(s) requested by the client while the surface was fullscreen
//
// The compositor may include the previous window geometry dimensions in
// the configure event, if applicable.
//
// The client must also acknowledge the configure when committing the new
// content (see ack_configure).
//
func (i *Toplevel) UnsetFullscreen() error {
	const opcode = 12
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// SetMinimized : set the window as minimized
//
// Request that the compositor minimize your surface. There is no
// way to know if the surface is currently minimized, nor is there
// any way to unset minimization on this surface.
//
// If you are looking to throttle redrawing when minimized, please
// instead use the wl_surface.frame event for this, as this will
// also work with live previews on windows in Alt-Tab, Expose or
// similar compositor features.
//
func (i *Toplevel) SetMinimized() error {
	const opcode = 13
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

type ToplevelError uint32

// ToplevelError :
const (
	// ToplevelErrorInvalidResizeEdge : provided value is not a valid variant of the resize_edge enum
	ToplevelErrorInvalidResizeEdge ToplevelError = 0
)

func (e ToplevelError) Name() string {
	switch e {
	case ToplevelErrorInvalidResizeEdge:
		return "invalid_resize_edge"
	default:
		return ""
	}
}

func (e ToplevelError) Value() string {
	switch e {
	case ToplevelErrorInvalidResizeEdge:
		return "0"
	default:
		return ""
	}
}

func (e ToplevelError) String() string {
	return e.Name() + "=" + e.Value()
}

type ToplevelResizeEdge uint32

// ToplevelResizeEdge : edge values for resizing
//
// These values are used to indicate which edge of a surface
// is being dragged in a resize operation.
const (
	ToplevelResizeEdgeNone        ToplevelResizeEdge = 0
	ToplevelResizeEdgeTop         ToplevelResizeEdge = 1
	ToplevelResizeEdgeBottom      ToplevelResizeEdge = 2
	ToplevelResizeEdgeLeft        ToplevelResizeEdge = 4
	ToplevelResizeEdgeTopLeft     ToplevelResizeEdge = 5
	ToplevelResizeEdgeBottomLeft  ToplevelResizeEdge = 6
	ToplevelResizeEdgeRight       ToplevelResizeEdge = 8
	ToplevelResizeEdgeTopRight    ToplevelResizeEdge = 9
	ToplevelResizeEdgeBottomRight ToplevelResizeEdge = 10
)

func (e ToplevelResizeEdge) Name() string {
	switch e {
	case ToplevelResizeEdgeNone:
		return "none"
	case ToplevelResizeEdgeTop:
		return "top"
	case ToplevelResizeEdgeBottom:
		return "bottom"
	case ToplevelResizeEdgeLeft:
		return "left"
	case ToplevelResizeEdgeTopLeft:
		return "top_left"
	case ToplevelResizeEdgeBottomLeft:
		return "bottom_left"
	case ToplevelResizeEdgeRight:
		return "right"
	case ToplevelResizeEdgeTopRight:
		return "top_right"
	case ToplevelResizeEdgeBottomRight:
		return "bottom_right"
	default:
		return ""
	}
}

func (e ToplevelResizeEdge) Value() string {
	switch e {
	case ToplevelResizeEdgeNone:
		return "0"
	case ToplevelResizeEdgeTop:
		return "1"
	case ToplevelResizeEdgeBottom:
		return "2"
	case ToplevelResizeEdgeLeft:
		return "4"
	case ToplevelResizeEdgeTopLeft:
		return "5"
	case ToplevelResizeEdgeBottomLeft:
		return "6"
	case ToplevelResizeEdgeRight:
		return "8"
	case ToplevelResizeEdgeTopRight:
		return "9"
	case ToplevelResizeEdgeBottomRight:
		return "10"
	default:
		return ""
	}
}

func (e ToplevelResizeEdge) String() string {
	return e.Name() + "=" + e.Value()
}

type ToplevelState uint32

// ToplevelState : types of state on the surface
//
// The different state values used on the surface. This is designed for
// state values like maximized, fullscreen. It is paired with the
// configure event to ensure that both the client and the compositor
// setting the state can be synchronized.
//
// States set in this way are double-buffered. They will get applied on
// the next commit.
const (
	// ToplevelStateMaximized : the surface is maximized
	ToplevelStateMaximized ToplevelState = 1
	// ToplevelStateFullscreen : the surface is fullscreen
	ToplevelStateFullscreen ToplevelState = 2
	// ToplevelStateResizing : the surface is being resized
	ToplevelStateResizing ToplevelState = 3
	// ToplevelStateActivated : the surface is now activated
	ToplevelStateActivated   ToplevelState = 4
	ToplevelStateTiledLeft   ToplevelState = 5
	ToplevelStateTiledRight  ToplevelState = 6
	ToplevelStateTiledTop    ToplevelState = 7
	ToplevelStateTiledBottom ToplevelState = 8
)

func (e ToplevelState) Name() string {
	switch e {
	case ToplevelStateMaximized:
		return "maximized"
	case ToplevelStateFullscreen:
		return "fullscreen"
	case ToplevelStateResizing:
		return "resizing"
	case ToplevelStateActivated:
		return "activated"
	case ToplevelStateTiledLeft:
		return "tiled_left"
	case ToplevelStateTiledRight:
		return "tiled_right"
	case ToplevelStateTiledTop:
		return "tiled_top"
	case ToplevelStateTiledBottom:
		return "tiled_bottom"
	default:
		return ""
	}
}

func (e ToplevelState) Value() string {
	switch e {
	case ToplevelStateMaximized:
		return "1"
	case ToplevelStateFullscreen:
		return "2"
	case ToplevelStateResizing:
		return "3"
	case ToplevelStateActivated:
		return "4"
	case ToplevelStateTiledLeft:
		return "5"
	case ToplevelStateTiledRight:
		return "6"
	case ToplevelStateTiledTop:
		return "7"
	case ToplevelStateTiledBottom:
		return "8"
	default:
		return ""
	}
}

func (e ToplevelState) String() string {
	return e.Name() + "=" + e.Value()
}

// ToplevelConfigureEvent : suggest a surface change
//
// This configure event asks the client to resize its toplevel surface or
// to change its state. The configured state should not be applied
// immediately. See xdg_surface.configure for details.
//
// The width and height arguments specify a hint to the window
// about how its surface should be resized in window geometry
// coordinates. See set_window_geometry.
//
// If the width or height arguments are zero, it means the client
// should decide its own window dimension. This may happen when the
// compositor needs to configure the state of the surface but doesn't
// have any information about any previous or expected dimension.
//
// The states listed in the event specify how the width/height
// arguments should be interpreted, and possibly how it should be
// drawn.
//
// Clients must send an ack_configure in response to this event. See
// xdg_surface.configure and xdg_surface.ack_configure for details.
type ToplevelConfigureEvent struct {
	Width  int32
	Height int32
	States []byte
}
type ToplevelConfigureHandlerFunc func(ToplevelConfigureEvent)

// AddConfigureHandler : adds handler for ToplevelConfigureEvent
func (i *Toplevel) AddConfigureHandler(f ToplevelConfigureHandlerFunc) {
	if f == nil {
		return
	}

	i.configureHandlers = append(i.configureHandlers, f)
}

// ToplevelCloseEvent : surface wants to be closed
//
// The close event is sent by the compositor when the user
// wants the surface to be closed. This should be equivalent to
// the user clicking the close button in client-side decorations,
// if your application has any.
//
// This is only a request that the user intends to close the
// window. The client may choose to ignore this request, or show
// a dialog to ask the user to save their data, etc.
type ToplevelCloseEvent struct{}
type ToplevelCloseHandlerFunc func(ToplevelCloseEvent)

// AddCloseHandler : adds handler for ToplevelCloseEvent
func (i *Toplevel) AddCloseHandler(f ToplevelCloseHandlerFunc) {
	if f == nil {
		return
	}

	i.closeHandlers = append(i.closeHandlers, f)
}

// ToplevelConfigureBoundsEvent : recommended window geometry bounds
//
// The configure_bounds event may be sent prior to a xdg_toplevel.configure
// event to communicate the bounds a window geometry size is recommended
// to constrain to.
//
// The passed width and height are in surface coordinate space. If width
// and height are 0, it means bounds is unknown and equivalent to as if no
// configure_bounds event was ever sent for this surface.
//
// The bounds can for example correspond to the size of a monitor excluding
// any panels or other shell components, so that a surface isn't created in
// a way that it cannot fit.
//
// The bounds may change at any point, and in such a case, a new
// xdg_toplevel.configure_bounds will be sent, followed by
// xdg_toplevel.configure and xdg_surface.configure.
type ToplevelConfigureBoundsEvent struct {
	Width  int32
	Height int32
}
type ToplevelConfigureBoundsHandlerFunc func(ToplevelConfigureBoundsEvent)

// AddConfigureBoundsHandler : adds handler for ToplevelConfigureBoundsEvent
func (i *Toplevel) AddConfigureBoundsHandler(f ToplevelConfigureBoundsHandlerFunc) {
	if f == nil {
		return
	}

	i.configureBoundsHandlers = append(i.configureBoundsHandlers, f)
}

func (i *Toplevel) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.configureHandlers) == 0 {
			return
		}
		var e ToplevelConfigureEvent
		l := 0
		e.Width = int32(client.Uint32(data[l : l+4]))
		l += 4
		e.Height = int32(client.Uint32(data[l : l+4]))
		l += 4
		statesLen := int(client.Uint32(data[l : l+4]))
		l += 4
		e.States = make([]byte, statesLen)
		copy(e.States, data[l:l+statesLen])
		l += statesLen
		for _, f := range i.configureHandlers {
			f(e)
		}
	case 1:
		if len(i.closeHandlers) == 0 {
			return
		}
		var e ToplevelCloseEvent
		for _, f := range i.closeHandlers {
			f(e)
		}
	case 2:
		if len(i.configureBoundsHandlers) == 0 {
			return
		}
		var e ToplevelConfigureBoundsEvent
		l := 0
		e.Width = int32(client.Uint32(data[l : l+4]))
		l += 4
		e.Height = int32(client.Uint32(data[l : l+4]))
		l += 4
		for _, f := range i.configureBoundsHandlers {
			f(e)
		}
	}
}

// Popup : short-lived, popup surfaces for menus
//
// A popup surface is a short-lived, temporary surface. It can be used to
// implement for example menus, popovers, tooltips and other similar user
// interface concepts.
//
// A popup can be made to take an explicit grab. See xdg_popup.grab for
// details.
//
// When the popup is dismissed, a popup_done event will be sent out, and at
// the same time the surface will be unmapped. See the xdg_popup.popup_done
// event for details.
//
// Explicitly destroying the xdg_popup object will also dismiss the popup and
// unmap the surface. Clients that want to dismiss the popup when another
// surface of their own is clicked should dismiss the popup using the destroy
// request.
//
// A newly created xdg_popup will be stacked on top of all previously created
// xdg_popup surfaces associated with the same xdg_toplevel.
//
// The parent of an xdg_popup must be mapped (see the xdg_surface
// description) before the xdg_popup itself.
//
// The client must call wl_surface.commit on the corresponding wl_surface
// for the xdg_popup state to take effect.
type Popup struct {
	client.BaseProxy
	configureHandlers    []PopupConfigureHandlerFunc
	popupDoneHandlers    []PopupPopupDoneHandlerFunc
	repositionedHandlers []PopupRepositionedHandlerFunc
}

// NewPopup : short-lived, popup surfaces for menus
//
// A popup surface is a short-lived, temporary surface. It can be used to
// implement for example menus, popovers, tooltips and other similar user
// interface concepts.
//
// A popup can be made to take an explicit grab. See xdg_popup.grab for
// details.
//
// When the popup is dismissed, a popup_done event will be sent out, and at
// the same time the surface will be unmapped. See the xdg_popup.popup_done
// event for details.
//
// Explicitly destroying the xdg_popup object will also dismiss the popup and
// unmap the surface. Clients that want to dismiss the popup when another
// surface of their own is clicked should dismiss the popup using the destroy
// request.
//
// A newly created xdg_popup will be stacked on top of all previously created
// xdg_popup surfaces associated with the same xdg_toplevel.
//
// The parent of an xdg_popup must be mapped (see the xdg_surface
// description) before the xdg_popup itself.
//
// The client must call wl_surface.commit on the corresponding wl_surface
// for the xdg_popup state to take effect.
func NewPopup(ctx *client.Context) *Popup {
	xdgPopup := &Popup{}
	ctx.Register(xdgPopup)
	return xdgPopup
}

// Destroy : remove xdg_popup interface
//
// This destroys the popup. Explicitly destroying the xdg_popup
// object will also dismiss the popup, and unmap the surface.
//
// If this xdg_popup is not the "topmost" popup, a protocol error
// will be sent.
//
func (i *Popup) Destroy() error {
	defer i.Context().Unregister(i)
	const opcode = 0
	const rLen = 8
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// Grab : make the popup take an explicit grab
//
// This request makes the created popup take an explicit grab. An explicit
// grab will be dismissed when the user dismisses the popup, or when the
// client destroys the xdg_popup. This can be done by the user clicking
// outside the surface, using the keyboard, or even locking the screen
// through closing the lid or a timeout.
//
// If the compositor denies the grab, the popup will be immediately
// dismissed.
//
// This request must be used in response to some sort of user action like a
// button press, key press, or touch down event. The serial number of the
// event should be passed as 'serial'.
//
// The parent of a grabbing popup must either be an xdg_toplevel surface or
// another xdg_popup with an explicit grab. If the parent is another
// xdg_popup it means that the popups are nested, with this popup now being
// the topmost popup.
//
// Nested popups must be destroyed in the reverse order they were created
// in, e.g. the only popup you are allowed to destroy at all times is the
// topmost one.
//
// When compositors choose to dismiss a popup, they may dismiss every
// nested grabbing popup as well. When a compositor dismisses popups, it
// will follow the same dismissing order as required from the client.
//
// The parent of a grabbing popup must either be another xdg_popup with an
// active explicit grab, or an xdg_popup or xdg_toplevel, if there are no
// explicit grabs already taken.
//
// If the topmost grabbing popup is destroyed, the grab will be returned to
// the parent of the popup, if that parent previously had an explicit grab.
//
// If the parent is a grabbing popup which has already been dismissed, this
// popup will be immediately dismissed. If the parent is a popup that did
// not take an explicit grab, an error will be raised.
//
// During a popup grab, the client owning the grab will receive pointer
// and touch events for all their surfaces as normal (similar to an
// "owner-events" grab in X11 parlance), while the top most grabbing popup
// will always have keyboard focus.
//
//  seat: the wl_seat of the user event
//  serial: the serial of the user event
func (i *Popup) Grab(seat *client.Seat, serial uint32) error {
	const opcode = 1
	const rLen = 8 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], seat.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(serial))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

// Reposition : recalculate the popup's location
//
// Reposition an already-mapped popup. The popup will be placed given the
// details in the passed xdg_positioner object, and a
// xdg_popup.repositioned followed by xdg_popup.configure and
// xdg_surface.configure will be emitted in response. Any parameters set
// by the previous positioner will be discarded.
//
// The passed token will be sent in the corresponding
// xdg_popup.repositioned event. The new popup position will not take
// effect until the corresponding configure event is acknowledged by the
// client. See xdg_popup.repositioned for details. The token itself is
// opaque, and has no other special meaning.
//
// If multiple reposition requests are sent, the compositor may skip all
// but the last one.
//
// If the popup is repositioned in response to a configure event for its
// parent, the client should send an xdg_positioner.set_parent_configure
// and possibly an xdg_positioner.set_parent_size request to allow the
// compositor to properly constrain the popup.
//
// If the popup is repositioned together with a parent that is being
// resized, but not in response to a configure event, the client should
// send an xdg_positioner.set_parent_size request.
//
//  token: reposition request token
func (i *Popup) Reposition(positioner *Positioner, token uint32) error {
	const opcode = 2
	const rLen = 8 + 4 + 4
	r := make([]byte, rLen)
	l := 0
	client.PutUint32(r[l:4], i.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(rLen<<16|opcode&0x0000ffff))
	l += 4
	client.PutUint32(r[l:l+4], positioner.ID())
	l += 4
	client.PutUint32(r[l:l+4], uint32(token))
	l += 4
	err := i.Context().WriteMsg(r, nil)
	return err
}

type PopupError uint32

// PopupError :
const (
	// PopupErrorInvalidGrab : tried to grab after being mapped
	PopupErrorInvalidGrab PopupError = 0
)

func (e PopupError) Name() string {
	switch e {
	case PopupErrorInvalidGrab:
		return "invalid_grab"
	default:
		return ""
	}
}

func (e PopupError) Value() string {
	switch e {
	case PopupErrorInvalidGrab:
		return "0"
	default:
		return ""
	}
}

func (e PopupError) String() string {
	return e.Name() + "=" + e.Value()
}

// PopupConfigureEvent : configure the popup surface
//
// This event asks the popup surface to configure itself given the
// configuration. The configured state should not be applied immediately.
// See xdg_surface.configure for details.
//
// The x and y arguments represent the position the popup was placed at
// given the xdg_positioner rule, relative to the upper left corner of the
// window geometry of the parent surface.
//
// For version 2 or older, the configure event for an xdg_popup is only
// ever sent once for the initial configuration. Starting with version 3,
// it may be sent again if the popup is setup with an xdg_positioner with
// set_reactive requested, or in response to xdg_popup.reposition requests.
type PopupConfigureEvent struct {
	X      int32
	Y      int32
	Width  int32
	Height int32
}
type PopupConfigureHandlerFunc func(PopupConfigureEvent)

// AddConfigureHandler : adds handler for PopupConfigureEvent
func (i *Popup) AddConfigureHandler(f PopupConfigureHandlerFunc) {
	if f == nil {
		return
	}

	i.configureHandlers = append(i.configureHandlers, f)
}

// PopupPopupDoneEvent : popup interaction is done
//
// The popup_done event is sent out when a popup is dismissed by the
// compositor. The client should destroy the xdg_popup object at this
// point.
type PopupPopupDoneEvent struct{}
type PopupPopupDoneHandlerFunc func(PopupPopupDoneEvent)

// AddPopupDoneHandler : adds handler for PopupPopupDoneEvent
func (i *Popup) AddPopupDoneHandler(f PopupPopupDoneHandlerFunc) {
	if f == nil {
		return
	}

	i.popupDoneHandlers = append(i.popupDoneHandlers, f)
}

// PopupRepositionedEvent : signal the completion of a repositioned request
//
// The repositioned event is sent as part of a popup configuration
// sequence, together with xdg_popup.configure and lastly
// xdg_surface.configure to notify the completion of a reposition request.
//
// The repositioned event is to notify about the completion of a
// xdg_popup.reposition request. The token argument is the token passed
// in the xdg_popup.reposition request.
//
// Immediately after this event is emitted, xdg_popup.configure and
// xdg_surface.configure will be sent with the updated size and position,
// as well as a new configure serial.
//
// The client should optionally update the content of the popup, but must
// acknowledge the new popup configuration for the new position to take
// effect. See xdg_surface.ack_configure for details.
type PopupRepositionedEvent struct {
	Token uint32
}
type PopupRepositionedHandlerFunc func(PopupRepositionedEvent)

// AddRepositionedHandler : adds handler for PopupRepositionedEvent
func (i *Popup) AddRepositionedHandler(f PopupRepositionedHandlerFunc) {
	if f == nil {
		return
	}

	i.repositionedHandlers = append(i.repositionedHandlers, f)
}

func (i *Popup) Dispatch(opcode uint16, fd uintptr, data []byte) {
	switch opcode {
	case 0:
		if len(i.configureHandlers) == 0 {
			return
		}
		var e PopupConfigureEvent
		l := 0
		e.X = int32(client.Uint32(data[l : l+4]))
		l += 4
		e.Y = int32(client.Uint32(data[l : l+4]))
		l += 4
		e.Width = int32(client.Uint32(data[l : l+4]))
		l += 4
		e.Height = int32(client.Uint32(data[l : l+4]))
		l += 4
		for _, f := range i.configureHandlers {
			f(e)
		}
	case 1:
		if len(i.popupDoneHandlers) == 0 {
			return
		}
		var e PopupPopupDoneEvent
		for _, f := range i.popupDoneHandlers {
			f(e)
		}
	case 2:
		if len(i.repositionedHandlers) == 0 {
			return
		}
		var e PopupRepositionedEvent
		l := 0
		e.Token = client.Uint32(data[l : l+4])
		l += 4
		for _, f := range i.repositionedHandlers {
			f(e)
		}
	}
}
